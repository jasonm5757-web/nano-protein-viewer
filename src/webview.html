<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Molstar-based Protein Visualizer</title>
    <!-- Molstar CSS -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.css" />
    <!-- Molstar JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.js"></script>
    <!-- JSZip for creating ZIP files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scrollbars */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: hsl(210, 40%, 98%);
        }
        #container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        /* --- Left Control Panel --- */
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: hsl(0, 0%, 100%);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px hsl(220, 13%, 91%), 0 2px 4px -1px hsl(220, 13%, 91%);
            border: 1px solid hsl(220, 13%, 91%);
            z-index: 100;
            max-width: 320px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        #controls-content {
            overflow-y: visible;
            overflow-x: hidden;
        }
        
        #controls.collapsed {
            max-width: 60px;
            padding: 15px;
        }
        
        #controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        #controls-header h2 {
            margin: 0;
            font-size: 18px;
            color: hsl(220, 9%, 46%);
        }
        
        #controls.collapsed #controls-header h2 {
            display: none;
        }
        
        #toggle-controls {
            width: auto !important;
            min-width: 30px !important;
            padding: 4px 8px !important;
            margin: 0 !important;
            font-size: 14px !important;
            background: hsl(220, 13%, 91%) !important;
            color: hsl(220, 9%, 46%) !important;
            border-radius: 4px !important;
            box-shadow: none !important;
        }
        
        #toggle-controls:hover {
            background: hsl(220, 13%, 85%) !important;
        }
        
        #controls-content {
            flex: 1;
            transition: all 0.3s ease;
        }
        
        #controls.collapsed #controls-content {
            display: none;
        }
        /* --- Right File List Panel --- */
        #file-list-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 280px;
            max-height: calc(100vh - 20px);
            background: hsl(0, 0%, 100%);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px hsl(220, 13%, 91%), 0 2px 4px -1px hsl(220, 13%, 91%);
            border: 1px solid hsl(220, 13%, 91%);
            z-index: 90;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease-in-out;
        }
        
        #file-list-panel.collapsed {
            width: 60px;
            padding: 15px;
        }
         /* --- File List Header --- */
        #file-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid hsl(220, 13%, 91%);
        }
        
        #file-list-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #file-list-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #download-all-files {
            width: 24px !important;
            height: 24px !important;
            min-width: 24px !important;
            padding: 4px !important;
            margin: 0 !important;
            font-size: 12px !important;
            background: hsl(220, 13%, 91%) !important;
            color: hsl(220, 9%, 46%) !important;
            border-radius: 4px !important;
            box-shadow: none !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        
        #download-all-files:hover {
            background: hsl(220, 13%, 85%) !important;
        }
        
        #download-all-files svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }
        
        #file-list-header h3 {
            margin: 0;
            border: none;
            padding: 0;
            font-size: 16px;
            color: hsl(220, 9%, 46%);
        }
        
        #file-list-panel.collapsed #file-list-header h3 {
            display: none;
        }
        
        #file-list-panel.collapsed #file-list-header-left {
            display: none;
        }
        
        #file-list-panel.collapsed #download-all-files {
            display: none !important;
        }
        
        #file-list-panel.collapsed #file-list-header {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
            justify-content: center;
        }
        
        #toggle-file-list {
            width: auto !important;
            min-width: 30px !important;
            padding: 4px 8px !important;
            margin: 0 !important;
            font-size: 14px !important;
            line-height: 1;
            background: hsl(220, 13%, 91%) !important;
            color: hsl(220, 9%, 46%) !important;
            border-radius: 4px !important;
            box-shadow: none !important;
        }
        
        #toggle-file-list:hover {
            background: hsl(220, 13%, 85%) !important;
        }
        /* --- File History Styling (includes collapse) --- */
        #file-history {
            border: 1px solid hsl(220, 13%, 91%);
            padding: 5px;
            flex-grow: 1;
            min-height: 50px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, border-width 0.3s ease-in-out, padding 0.3s ease-in-out, margin-top 0.3s ease-in-out, min-height 0.3s ease-in-out;
            margin-top: 5px;
            opacity: 1;
        }
        
        #file-history.collapsed {
            max-height: 0;
            min-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            border-width: 0;
            overflow: hidden;
            opacity: 0;
            margin-top: 0;
        }
        
        #file-list-panel.collapsed #file-history {
            display: none;
        }
        .file-item {
            padding: 6px 8px;
            background-color: #f0f0f0;
            margin-bottom: 5px;
            border-radius: 3px;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 13px;
            border-left: 3px solid transparent;
            color: hsl(220, 9%, 46%);
        }
        .file-item:hover {
            background-color: #e0e0e0;
        }
        .file-item.active {
            background-color: #d1e7dd;
            border-left: 3px solid #4CAF50;
            font-weight: bold;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .file-item-content {
            flex: 1;
            min-width: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-item-name {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .file-download-icon {
            width: 18px;
            height: 18px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s ease;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            padding: 2px;
        }
        
        .file-download-icon:hover {
            opacity: 1;
            background-color: rgba(0, 0, 0, 0.1);
        }
        
        .file-download-icon svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }
        /* --- Other Controls --- */
        button {
            padding: 10px 16px;
            background: hsl(220, 9%, 46%);
            border: none;
            border-radius: 6px;
            color: hsl(210 40% 98%);
            cursor: pointer;
            margin: 5px 0;
            width: 100%;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px 0 hsl(220, 13%, 91%);
        }
        button:hover {
            background: hsl(220, 9%, 41%);
            box-shadow: 0 2px 4px 0 hsl(220, 13%, 91%);
        }
        button:active {
            background: hsl(220, 9%, 36%);
        }
        .slider-container { margin: 10px 0; }
        .slider-container label { display: block; margin-bottom: 5px; font-size: 14px; }
        .slider-container input[type=range] { width: 100%; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.75); color: white; padding: 20px 35px;
            border-radius: 8px; display: none; z-index: 200; font-size: 16px;
        }
        #status { margin-top: 10px; font-size: 14px; color: hsl(220, 9%, 46%); }
        #atom-count { font-weight: bold; }
        #animation-controls { margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; }
        #animation-slider { width: 100%; margin: 10px 0; }
        #frame-info { text-align: center; margin: 5px 0; font-size: 14px; }
        
        /* Animation Controls Styling */
        .animation-main-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin: 15px 0;
        }
        
        .animation-direction-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
        }
        
        .direction-label {
            font-size: 12px;
            color: hsl(220, 9%, 46%);
            font-weight: 500;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .control-btn {
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px 0 hsl(220, 13%, 91%);
        }
        
        .control-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px 0 hsl(220, 13%, 91%);
        }
        
        .control-btn:active {
            transform: translateY(0);
        }
        
        .play-btn {
            background: hsl(220, 9%, 46%);
            color: hsl(210 40% 98%);
            padding: 8px 12px;
            font-size: 14px;
            min-width: 40px;
        }
        
        .play-btn:hover {
            background: hsl(220, 9%, 41%);
        }
        
        .play-btn.playing {
            background: hsl(220, 9%, 46%);
            color: hsl(210 40% 98%);
        }
        
        .play-btn.playing:hover {
            background: hsl(220, 9%, 41%);
        }
        
        .step-btn {
            background: hsl(0 0% 100%);
            color: hsl(220, 9%, 46%);
            border: 1px solid hsl(214.3 31.8% 91.4%);
            padding: 8px 12px;
            font-size: 14px;
            min-width: 40px;
        }
        
        .step-btn:hover {
            background: hsl(210 40% 98%);
        }
        
        .direction-btn {
            background: hsl(0 0% 100%);
            color: hsl(220, 9%, 46%);
            border: 1px solid hsl(214.3 31.8% 91.4%);
            padding: 8px 12px;
            font-size: 14px;
            min-width: 40px;
        }
        
        .direction-btn:hover {
            background: hsl(210 40% 98%);
        }
        
        .direction-btn.active {
            background: hsl(220, 9%, 46%);
            color: hsl(210 40% 98%);
            border-color: hsl(220, 9%, 46%);
        }
        
        .animation-download-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
            position: relative;
        }
        
        .download-btn {
            background: hsl(220, 9%, 46%);
            color: hsl(210 40% 98%);
            padding: 8px 16px;
            font-size: 13px;
            width: 100%;
            margin-bottom: 8px;
        }
        
        .download-btn:hover {
            background: hsl(220, 9%, 41%);
        }
        
        .download-options {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        
        .download-option {
            background: hsl(0 0% 100%);
            color: hsl(220, 9%, 46%);
            border: 1px solid hsl(214.3 31.8% 91.4%);
            padding: 6px 12px;
            font-size: 11px;
            flex: 1;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .download-option:hover {
            background: hsl(210 40% 98%);
        }
        
        /* pLDDT Confidence Info Section */
        .plddt-info-section {
            margin: 10px 0;
            padding: 10px 0;
            border-top: 1px solid hsl(214.3 31.8% 91.4%);
        }
        
        .plddt-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .plddt-info-header h4 {
            margin: 0;
            font-size: 13px;
            color: hsl(215.4 16.3% 46.9%);
            font-weight: 600;
        }
        
        .plddt-info-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .plddt-info-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .plddt-info-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .plddt-info-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .plddt-info-slider {
            background-color: hsl(220, 9%, 46%);
        }
        
        input:checked + .plddt-info-slider:before {
            transform: translateX(26px);
        }
        
        .plddt-info-content {
            display: none;
        }
        
        .plddt-info-content.active {
            display: block;
        }
        
        .plddt-info-panel {
            background: hsl(210 40% 98%);
            border: 1px solid hsl(214.3 31.8% 91.4%);
            padding: 16px;
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .plddt-description {
            font-size: 12px;
            color: hsl(215.4 16.3% 46.9%);
            margin-bottom: 12px;
        }
        
        .plddt-legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .plddt-item {
            display: flex;
            align-items: center;
            font-size: 12px;
            color: hsl(215.4 16.3% 46.9%);
        }
        
        .plddt-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 8px;
            border: 1px solid hsl(214.3 31.8% 91.4%);
        }
        
        .input-container { margin-bottom: 10px; }
        h2, h3, h4 { 
            margin-top: 5px; 
            color: hsl(220, 9%, 46%);
        }
        /* Format badges */
        .format-badge {
            display: inline-block;
            margin-left: 5px;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: normal;
            background-color: #e0e0e0;
            color: #333;
        }
        .format-badge.pdb {
            background-color: #d1e7dd;
            color: #0f5132;
        }
        .format-badge.mmcif {
            background-color: #cfe2ff;
            color: #084298;
        }
        .format-badge.pdbqt {
            background-color: #e2e3e5;
            color: #383d41;
        }
        .format-badge.gro {
            background-color: #fff3cd;
            color: #856404;
        }
        .format-badge.xyz {
            background-color: #d4edda;
            color: #155724;
        }
        .format-badge.mol {
            background-color: #f8d7da;
            color: #721c24;
        }
        .format-badge.mol2 {
            background-color: #fce4ec;
            color: #880e4f;
        }
        .format-badge.sdf {
            background-color: #e1f5fe;
            color: #01579b;
        }
        
        /* View Mode Controls - Removed, using cartoon mode only */
        
        /* Layout Mode Controls */
        .layout-mode-controls {
            margin: 15px 0;
            padding: 10px 0;
            border-bottom: 1px solid #ddd;
        }
        .layout-buttons {
            display: flex;
            gap: 5px;
        }
        .layout-buttons button {
            flex: 1;
            padding: 8px 12px;
            font-size: 14px;
            margin: 0;
        }
        .layout-buttons button.active {
            background-color: hsl(222.2 84% 4.9%);
        }
        .layout-buttons button.active:hover {
            background-color: hsl(222.2 84% 4.9% / 0.9);
        }
        
        /* Color Controls */
        .color-controls {
            margin: 15px 0;
            padding: 10px 0;
            border-top: 1px solid #ddd;
        }

        .color-controls-right {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        /* Color Mode Dropdown */
        .color-mode-dropdown {
            position: relative;
        }

        .color-mode-toggle {
            background: hsl(0 0% 100%);
            border: 1px solid hsl(214.3 31.8% 91.4%);
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: hsl(220, 9%, 46%);
            transition: all 0.2s ease;
            min-width: 100px;
        }

        .color-mode-toggle:hover {
            background: hsl(210 40% 98%);
            border-color: hsl(220, 9%, 46%);
        }

        .dropdown-arrow {
            font-size: 10px;
            transition: transform 0.2s ease;
        }

        .color-mode-dropdown.open .dropdown-arrow {
            transform: rotate(180deg);
        }

        .color-mode-options {
            position: fixed;
            background: hsl(0 0% 100%);
            border: 1px solid hsl(214.3 31.8% 91.4%);
            border-radius: 6px;
            box-shadow: 0 4px 6px -1px hsl(220, 13%, 91%), 0 2px 4px -1px hsl(220, 13%, 91%);
            min-width: 160px;
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 10000;
        }

        .color-mode-dropdown.open .color-mode-options {
            max-height: 500px;
            overflow-y: auto;
            opacity: 1;
            visibility: visible;
        }

        .color-mode-option {
            padding: 10px 16px;
            font-size: 12px;
            cursor: pointer;
            color: hsl(220, 9%, 46%);
            transition: background 0.2s ease;
            position: relative;
        }

        .color-mode-option:first-child {
            border-radius: 6px 6px 0 0;
        }

        .color-mode-option:last-child {
            border-radius: 0 0 6px 6px;
        }

        .color-mode-option:hover {
            background: hsl(210 40% 98%);
        }

        .color-mode-option.active {
            background: hsl(220, 9%, 46%);
            color: hsl(210 40% 98%);
            font-weight: 500;
        }

        .color-mode-option[data-mode="rainbow"] {
            position: relative;
            padding: 0;
        }

        .rainbow-main-label {
            padding: 10px 16px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .color-mode-option[data-mode="rainbow"]:hover .rainbow-main-label {
            background: hsl(210 40% 98%);
        }

        .color-mode-option[data-mode="rainbow"].active .rainbow-main-label {
            background: hsl(220, 9%, 46%);
            color: hsl(210 40% 98%);
        }

        .rainbow-palette-options {
            padding: 4px 0;
            display: none;
            border-top: 1px solid hsl(214.3 31.8% 91.4%);
            background: hsl(0 0% 100%);
        }

        .color-mode-option[data-mode="rainbow"]:hover .rainbow-palette-options,
        .color-mode-option[data-mode="rainbow"].expanded .rainbow-palette-options {
            display: block;
        }

        .palette-option {
            padding: 8px 16px;
            font-size: 11px;
            cursor: pointer;
            color: hsl(220, 9%, 46%);
            transition: background 0.2s ease;
            white-space: nowrap;
        }

        .palette-option:hover {
            background: hsl(214.3 31.8% 91.4%);
        }

        .palette-option.active {
            background: hsl(220, 9%, 46%);
            color: hsl(210 40% 98%);
        }

        /* Illustrative Style Switch */
        .illustrative-style-switch {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 11px;
            color: hsl(220, 9%, 46%);
        }

        .illustrative-style-switch input {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        }

        .illustrative-style-slider {
            position: relative;
            width: 40px;
            height: 20px;
            background-color: #ccc;
            border-radius: 20px;
            transition: .4s;
        }

        .illustrative-style-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
        }

        .illustrative-style-switch input:checked + .illustrative-style-slider {
            background-color: hsl(220, 9%, 46%);
        }

        .illustrative-style-switch input:checked + .illustrative-style-slider:before {
            transform: translateX(20px);
        }

        /* Color Palette */
        .custom-colors {
            margin-top: 10px;
        }
        .color-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }
        .color-option:hover {
            border-color: #666;
            transform: scale(1.1);
        }
        .color-option.active {
            border-color: hsl(222.2 84% 4.9%);
            border-width: 3px;
        }
        
        /* Cartoon Controls removed per requirements */
        
        /* Sequence Alignment Controls */
        .seq-alignment-controls {
            margin: 15px 0;
            padding: 15px 0;
            border-top: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
        }
        
        .seq-alignment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .seq-alignment-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .seq-alignment-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .seq-alignment-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .seq-alignment-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .seq-alignment-slider {
            background-color: hsl(222.2 84% 4.9%);
        }
        
        input:checked + .seq-alignment-slider:before {
            transform: translateX(26px);
        }
        
        .seq-alignment-content {
            display: none;
        }
        
        .seq-alignment-content.active {
            display: block;
        }
        
        .input-mode-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .input-mode-buttons button {
            flex: 1;
            padding: 8px 12px;
            font-size: 14px;
            margin: 0;
        }
        
        .input-mode-buttons button.active {
            background-color: hsl(222.2 84% 4.9%);
        }
        
        .input-mode-buttons button.active:hover {
            background-color: hsl(222.2 84% 4.9% / 0.9);
        }
        
        .sequence-input-section {
            margin-bottom: 15px;
        }
        
        .sequence-textarea {
            width: 100%;
            height: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }
        
        .sequence-list {
            max-height: 120px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .sequence-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            font-size: 12px;
        }
        
        .sequence-item:last-child {
            border-bottom: none;
        }
        
        .sequence-item:hover {
            background-color: #f5f5f5;
        }
        
        .sequence-item.active {
            background-color: hsl(217.2 91.2% 59.8% / 0.1);
            border-left: 3px solid hsl(222.2 84% 4.9%);
        }
        
        .sequence-item.predicted {
            background-color: hsl(142.1 76.2% 36.3% / 0.1);
            border-left: 3px solid hsl(142.1 76.2% 36.3%);
        }
        
        .sequence-name {
            font-weight: bold;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: hsl(220, 9%, 46%); /* Darker text color */
        }
        
        .sequence-name-content {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            min-width: 0;
        }
        
        .sequence-rmsd-section {
            margin-left: auto;
            flex-shrink: 0;
        }
        
        .sequence-download-icon {
            width: 16px;
            height: 16px;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s ease;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            padding: 2px;
            color: hsl(220, 9%, 30%); /* Darker icon color */
        }
        
        .sequence-download-icon:hover {
            opacity: 1;
            background-color: rgba(0, 0, 0, 0.1);
        }
        
        .sequence-download-icon svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }
        
        .sequence-preview {
            font-family: monospace;
            font-size: 10px;
            color: #666;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .sequence-status {
            font-size: 10px;
            color: hsl(220, 9%, 46%);
            margin-top: 2px;
        }
        
        .rmsd-score {
            float: right;
            background: hsl(142.1 76.2% 36.3% / 0.1);
            color: hsl(142.1 76.2% 36.3%);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
        }
        
        .align-mode-section {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }
        
        .align-mode-switch {
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        /* 3DMol viewer container */
        #viewer-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Dual session containers */
        .dual-session-mode #viewer-container {
            display: none;
        }
        
        .dual-session-mode #dual-session-container {
            display: block;
        }
        
        .single-session-mode #dual-session-container {
            display: none;
        }
        
        #dual-session-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: none;
        }
        
        .dual-viewers {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            height: 100%;
            padding: 4px;
        }
        
        .dual-viewer-panel {
            background: hsl(0, 0%, 100%);
            border: 2px solid hsl(220, 13%, 91%);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .dual-viewer-header {
            background: hsl(220, 9%, 46%);
            color: hsl(210, 40%, 98%);
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 500;
            text-align: center;
        }
        
        .dual-viewer-content {
            height: calc(100% - 32px);
        }
        
        /* Grid View Styles */
        .grid-view {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
            padding: 10px;
            height: 100%;
            overflow-y: auto;
        }
        
        .grid-item {
            border: 2px solid hsl(220, 13%, 91%);
            border-radius: 12px;
            position: relative;
            min-height: 300px;
            background: hsl(0, 0%, 100%);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px 0 hsl(220, 13%, 91%);
        }
        
        .grid-item.loading {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .grid-preview-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 10px;
        }
        
        .grid-activation-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
            z-index: 20;
        }
        
        .grid-item:hover .grid-activation-overlay {
            opacity: 1;
        }
        
        .grid-expand-button {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.3;
            transition: all 0.2s ease;
            z-index: 25;
            pointer-events: auto;
        }
        
        .grid-expand-button:hover {
            opacity: 0.9;
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.1);
        }
        
        .grid-item.active .grid-expand-button {
            opacity: 0.6;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .grid-item:hover {
            border-color: hsl(221, 83%, 53%);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px 0 hsl(220, 13%, 91%);
        }
        
        .grid-item.active {
            border-color: hsl(142, 76%, 36%);
            border-width: 3px;
            box-shadow: 0 4px 8px 0 hsl(142, 76%, 91%);
        }
        
        .grid-item-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: hsl(220, 9%, 46%);
            color: hsl(210, 40%, 98%);
            padding: 10px 16px;
            font-size: 13px;
            font-weight: 500;
            z-index: 10;
            border-radius: 10px 10px 0 0;
        }
        
        .grid-item-viewer {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        
        .single-view #viewer-container {
            display: block !important;
            visibility: visible !important;
            z-index: 1;
        }
        
        .grid-view-mode #viewer-container {
            display: none !important;
            visibility: hidden !important;
            z-index: -1;
        }
        
        .grid-view-mode #grid-container {
            display: block;
        }
        
        .single-view #grid-container {
            display: none;
        }
        
        #grid-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* VSCode Integration Styles */
        .vscode-input-section {
            margin: 15px 0;
            padding: 15px 0;
            border-top: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
        }
        
        .vscode-input-section h3 {
            margin-bottom: 10px;
            color: hsl(220, 9%, 46%);
        }
        
        .vscode-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .vscode-button {
            padding: 8px 12px;
            font-size: 14px;
            margin: 0;
            background: hsl(220, 9%, 46%);
            color: hsl(210, 40%, 98%);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .vscode-button:hover {
            background: hsl(220, 9%, 41%);
        }
        
        .vscode-button:active {
            background: hsl(220, 9%, 36%);
        }
        
        /* Structure Alignment Controls */
        .structure-alignment-controls {
            margin: 15px 0;
            padding: 10px 0;
            border-top: 1px solid #ddd;
        }
        
        .structure-alignment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .structure-alignment-header h3 {
            margin: 0;
            font-size: 16px;
            color: hsl(220, 9%, 46%);
        }
        
        .structure-alignment-content {
            display: block;
        }
        
        .alignment-control-group {
            margin-bottom: 10px;
        }
        
        .alignment-stats {
            color: hsl(220, 9%, 46%) !important;
        }
        
        .alignment-stats div {
            margin-bottom: 5px;
            color: hsl(220, 9%, 46%) !important;
        }
        
        .alignment-stats strong {
            color: hsl(220, 9%, 46%) !important;
        }
        
        .alignment-stats span {
            color: hsl(220, 9%, 46%) !important;
        }
        
        .structure-toggle-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        
        .structure-toggle-item:hover {
            background: hsl(210, 40%, 98%);
        }
        
        .structure-toggle-item input[type="checkbox"] {
            margin: 0;
        }
        
        .structure-toggle-item label {
            cursor: pointer;
            font-size: 12px;
            color: hsl(220, 9%, 46%);
            flex: 1;
        }
        
        .sequence-alignment-display {
            user-select: text;
        }
        
        .sequence-alignment-line {
            margin-bottom: 2px;
            padding: 2px 0;
            cursor: pointer;
            transition: background 0.2s ease;
            color: hsl(220, 9%, 46%) !important;
        }
        
        .sequence-alignment-line:hover {
            background: hsl(210, 40%, 98%);
        }
        
        .sequence-alignment-line.highlighted {
            background: hsl(220, 9%, 91%);
        }
        
        .conserved-residue {
            background: #90EE90;
            color: #000 !important;
            padding: 1px 2px;
            border-radius: 2px;
            font-weight: 500;
        }
        
        .variable-residue {
            background: #FFB6C1;
            color: #000 !important;
            padding: 1px 2px;
            border-radius: 2px;
        }
        
        .gap-residue {
            color: #999 !important;
        }
    </style>
</head>
<body>
    <div id="container" class="single-view">
        <div id="controls">
            <div id="controls-header">
                <h2>Controls</h2>
                <button id="toggle-controls" title="Collapse Controls">[−]</button>
            </div>
            <div id="controls-content">
            <!-- VSCode Integration Section -->
            <div class="vscode-input-section">
                <h3>VSCode Integration</h3>
                <div class="vscode-buttons">
                    <button class="vscode-button" id="request-pdb-files">Load PDB Files</button>
                    <button class="vscode-button" id="request-folder">Load Folder</button>
                </div>
            </div>
            <button id="reset-view">Reset View</button>
            
            <!-- Cartoon mode is now the default and only view mode -->
            
            <!-- Layout Mode Controls -->
            <div class="layout-mode-controls">
                <h3>Layout</h3>
                <div class="layout-buttons">
                    <button id="single-view" class="active">Single</button>
                    <button id="grid-view">Grid</button>
                </div>
            </div>
            
            <!-- Cartoon controls removed per requirements -->
            
            
            <!-- Color Controls -->
            <div class="color-controls">
                <h3>Colors</h3>
                <div class="color-controls-right">
                        <!-- Color Mode Dropdown -->
                        <div class="color-mode-dropdown">
                            <button id="color-mode-button" class="color-mode-toggle">
                                <span id="color-mode-label">Custom</span>
                                <span class="dropdown-arrow">▼</span>
                            </button>
                            <div id="color-mode-options" class="color-mode-options">
                                <div class="color-mode-option" data-mode="custom">Custom</div>
                                <div class="color-mode-option" data-mode="element">Element</div>
                                <div class="color-mode-option" data-mode="residue">Residue</div>
                                <div class="color-mode-option" data-mode="chain">Chain</div>
                                <div class="color-mode-option" data-mode="rainbow">
                                    <div class="rainbow-main-label">Rainbow</div>
                                    <div class="rainbow-palette-options">
                                        <div class="palette-option" data-palette="rainbow">Classic</div>
                                        <div class="palette-option" data-palette="viridis">Viridis</div>
                                        <div class="palette-option" data-palette="plasma">Plasma</div>
                                        <div class="palette-option" data-palette="magma">Magma</div>
                                        <div class="palette-option" data-palette="blue-red">Blue-Red</div>
                                        <div class="palette-option" data-palette="pastel">Pastel</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Illustrative Style Switch -->
                        <label class="illustrative-style-switch" title="Toggle Illustrative Style">
                            <input type="checkbox" id="illustrative-style-toggle">
                            <span class="illustrative-style-slider"></span>
                            <span class="illustrative-style-label">Illustrative</span>
                        </label>
                </div>

                <!-- Custom Color Palette -->
                <div id="custom-colors" class="custom-colors">
                    <div class="color-palette">
                        <div class="color-option" data-color="#4ECDC4" style="background-color: #4ECDC4;" title="Teal (Default)"></div>
                        <div class="color-option" data-color="#FF6B6B" style="background-color: #FF6B6B;" title="Red"></div>
                        <div class="color-option" data-color="#4DABF7" style="background-color: #4DABF7;" title="Blue"></div>
                        <div class="color-option" data-color="#69DB7C" style="background-color: #69DB7C;" title="Green"></div>
                        <div class="color-option" data-color="#FFD93D" style="background-color: #FFD93D;" title="Yellow"></div>
                        <div class="color-option" data-color="#FF922B" style="background-color: #FF922B;" title="Orange"></div>
                        <div class="color-option" data-color="#DA77F2" style="background-color: #DA77F2;" title="Purple"></div>
                        <div class="color-option" data-color="#FF8CC8" style="background-color: #FF8CC8;" title="Pink"></div>
                        <div class="color-option" data-color="#15AABF" style="background-color: #15AABF;" title="Cyan"></div>
                        <div class="color-option" data-color="#868E96" style="background-color: #868E96;" title="Gray"></div>
                    </div>
                </div>
            </div>
            
            <!-- Sequence Alignment Controls -->
            <div class="seq-alignment-controls">
                <div class="seq-alignment-header">
                    <h3>Seq Alignment</h3>
                    <label class="seq-alignment-switch">
                        <input type="checkbox" id="seq-alignment-toggle">
                        <span class="seq-alignment-slider"></span>
                    </label>
                </div>
                
                <div id="seq-alignment-content" class="seq-alignment-content">
                    <!-- Input Mode Selection -->
                    <div class="input-mode-buttons">
                        <button id="fasta-mode" class="active">FASTA File</button>
                        <button id="single-mode">Single Sequence</button>
                    </div>
                    
                    <!-- FASTA Input Section -->
                    <div id="fasta-input-section" class="sequence-input-section">
                        <input type="file" id="fasta-file-input" accept=".fasta,.fa,.fas,.txt" style="display: none;">
                        <button id="upload-fasta-btn">Upload FASTA File</button>
                        <div style="margin: 8px 0; text-align: center; color: hsl(220, 9%, 46%); font-size: 12px;">or</div>
                        <textarea id="fasta-textarea" class="sequence-textarea" placeholder="Paste FASTA sequences here...&#10;>sequence1&#10;MKLLILLVALLMLAATVFAAAAKKVFGRC...&#10;>sequence2&#10;GRCTKLLILLVALLMLAATVFAAAA..."></textarea>
                        <button id="parse-fasta-btn">Parse FASTA</button>
                    </div>
                    
                    <!-- Single Sequence Input Section -->
                    <div id="single-input-section" class="sequence-input-section" style="display: none;">
                        <input type="text" id="sequence-name" placeholder="Sequence name" style="width: 100%; margin-bottom: 8px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                        <textarea id="single-sequence-textarea" class="sequence-textarea" placeholder="Enter protein sequence...&#10;MKLLILLVALLMLAATVFAAAAKKVFGRC..."></textarea>
                        <button id="add-single-sequence-btn">Add Sequence</button>
                    </div>
                    
                    <!-- Parsed Sequences List -->
                    <div id="parsed-sequences-section" style="display: none;">
                        <h4 style="margin-bottom: 8px; font-size: 14px;">Parsed Sequences (<span id="sequence-count">0</span>)</h4>
                        <div id="sequence-list" class="sequence-list">
                            <!-- Sequences will be populated here -->
                        </div>
                        <button id="fold-all-btn" style="margin-bottom: 8px;">Fold All with ESMFold</button>
                        <button id="clear-sequences-btn" class="button secondary" style="font-size: 12px; padding: 6px 12px;">Clear All</button>
                    </div>
                    
                    <!-- Align Mode Section -->
                    <div id="align-mode-section" class="align-mode-section">
                        <h4 style="margin-bottom: 10px; font-size: 14px;">Display Mode</h4>
                        <div class="align-mode-options">
                            <label style="display: block; margin-bottom: 8px;">
                                <input type="radio" name="align-mode" id="dual-session-radio" value="dual" checked>
                                <span style="margin-left: 8px; color: hsl(220, 9%, 46%);">Dual Session (default)</span>
                            </label>
                            <div style="font-size: 11px; color: hsl(220, 9%, 46%); margin-left: 20px; margin-bottom: 8px;">
                                Original structure on left, predicted on right
                            </div>
                            
                            <label style="display: block; margin-bottom: 8px;">
                                <input type="radio" name="align-mode" id="seq-only-radio" value="seq-only">
                                <span style="margin-left: 8px; color: hsl(220, 9%, 46%);">Seq Structure Only</span>
                            </label>
                            <div style="font-size: 11px; color: hsl(220, 9%, 46%); margin-left: 20px; margin-bottom: 8px;">
                                Show only predicted structure from selected sequence
                            </div>
                            
                            <label style="display: block; margin-bottom: 8px;">
                                <input type="radio" name="align-mode" id="align-mode-radio" value="align">
                                <span style="margin-left: 8px; color: hsl(220, 9%, 46%);">Align Mode</span>
                            </label>
                            <div style="font-size: 11px; color: hsl(220, 9%, 46%); margin-left: 20px;">
                                Both structures in single session for manual alignment
                            </div>
                        </div>
                    </div>
                    
                    <!-- pLDDT Confidence Coloring Information (Subsection) -->
                    <div class="plddt-info-section">
                        <div class="plddt-info-header">
                            <h4>pLDDT Confidence Info</h4>
                            <label class="plddt-info-switch">
                                <input type="checkbox" id="plddt-info-toggle">
                                <span class="plddt-info-slider"></span>
                            </label>
                        </div>
                        
                        <div id="plddt-info-content" class="plddt-info-content">
                            <div class="plddt-info-panel">
                                <div class="plddt-description">
                                    Predicted structures are colored by confidence (pLDDT score):
                                </div>
                                <div class="plddt-legend">
                                    <div class="plddt-item">
                                        <div class="plddt-color" style="background: #0053D6;"></div>
                                        <span>Very High (>90)</span>
                                    </div>
                                    <div class="plddt-item">
                                        <div class="plddt-color" style="background: #65CBF3;"></div>
                                        <span>Confident (70-90)</span>
                                    </div>
                                    <div class="plddt-item">
                                        <div class="plddt-color" style="background: #FFDB13;"></div>
                                        <span>Low (50-70)</span>
                                    </div>
                                    <div class="plddt-item">
                                        <div class="plddt-color" style="background: #FF7D45;"></div>
                                        <span>Very Low (<50)</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Structure Alignment Controls -->
            <div class="structure-alignment-controls">
                <div class="structure-alignment-header">
                    <h3>Structure Alignment</h3>
                </div>
                
                <div id="structure-alignment-content" class="structure-alignment-content">
                    <div class="alignment-info" style="font-size: 12px; color: hsl(220, 9%, 46%); margin-bottom: 10px;">
                        Align multiple structures and identify conserved regions for cross-reactive binder design.
                    </div>
                    
                    <!-- Reference Structure Selection -->
                    <div class="alignment-control-group">
                        <label for="reference-structure-select" style="display: block; margin-bottom: 5px; font-size: 13px; color: hsl(220, 9%, 46%);">Reference Structure:</label>
                        <select id="reference-structure-select" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                            <option value="">Select reference structure...</option>
                        </select>
                    </div>
                    
                    <!-- Alignment Button -->
                    <button id="align-structures-btn" class="vscode-button" style="width: 100%; margin-top: 10px; margin-bottom: 10px;" disabled>
                        Align Structures
                    </button>
                    
                    <!-- Debug: Show Console Instructions -->
                    <div style="margin-top: 10px; padding: 8px; background: hsl(210, 40%, 98%); border-radius: 4px; font-size: 11px; color: hsl(220, 9%, 46%);">
                        <strong>Debug Console:</strong> Press <code>Ctrl+Shift+P</code> (or <code>Cmd+Shift+P</code> on Mac) and search for "Webview Developer Tools"
                    </div>
                    
                    <!-- Alignment Results Section -->
                    <div id="alignment-results-section" style="display: none;">
                        <div class="alignment-stats" style="margin-bottom: 10px; padding: 8px; background: hsl(210, 40%, 98%); border-radius: 4px; font-size: 12px;">
                            <div style="margin-bottom: 8px;"><strong>Structural Alignment:</strong></div>
                            <div style="margin-left: 10px; margin-bottom: 4px;"><strong>RMSD:</strong> <span id="alignment-rmsd">-</span> Å</div>
                            <div style="margin-left: 10px; margin-bottom: 4px;"><strong>Aligned Residues:</strong> <span id="aligned-residues-count">-</span></div>
                            <div style="margin-left: 10px; margin-bottom: 8px;"><strong>Coverage:</strong> <span id="alignment-coverage">-</span>%</div>
                            
                            <div style="margin-bottom: 8px; margin-top: 8px; border-top: 1px solid #ddd; padding-top: 8px;"><strong>Sequence Alignment:</strong></div>
                            <div style="margin-left: 10px; margin-bottom: 4px;"><strong>Sequence Identity:</strong> <span id="sequence-identity">-</span>%</div>
                            <div style="margin-left: 10px; margin-bottom: 4px;"><strong>Conserved Residues:</strong> <span id="conserved-count">-</span></div>
                            <div style="margin-left: 10px; margin-bottom: 4px;"><strong>Variable Residues:</strong> <span id="variable-count">-</span></div>
                        </div>
                        
                        <!-- Detailed Alignment Stats (per structure) -->
                        <div id="detailed-alignment-stats" style="margin-bottom: 10px; font-size: 11px;">
                            <!-- Detailed stats will be populated here -->
                        </div>
                        
                        <!-- Structure Toggle Controls -->
                        <div class="structure-toggle-controls" style="margin-bottom: 10px;">
                            <h4 style="font-size: 13px; margin-bottom: 5px; color: hsl(220, 9%, 46%);">Show/Hide Structures:</h4>
                            <div id="structure-toggle-list" style="display: flex; flex-direction: column; gap: 5px;">
                                <!-- Structure toggles will be populated here -->
                            </div>
                        </div>
                        
                        <!-- Export Button -->
                        <button id="export-conservation-btn" class="vscode-button" style="width: 100%; margin-bottom: 10px;">
                            Export Conservation Analysis
                        </button>
                    </div>
                    
                    <!-- Sequence Alignment View -->
                    <div id="sequence-alignment-view" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <h4 style="font-size: 13px; margin-bottom: 10px; color: hsl(220, 9%, 46%);">Sequence Alignment:</h4>
                        <div id="sequence-alignment-display" style="font-family: 'Courier New', monospace; font-size: 11px; background: hsl(0, 0%, 100%); border: 1px solid #ddd; border-radius: 4px; padding: 10px; max-height: 300px; overflow-y: auto; line-height: 1.4; color: hsl(220, 9%, 46%);">
                            <!-- Sequence alignment will be displayed here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="status"> Atoms: <span id="atom-count">0</span> </div>
            <div id="animation-controls" style="display: none;">
                <h3>Diffusion Animation</h3>
                <div id="frame-info">Step: <span id="current-step">0</span> / <span id="total-steps">0</span></div>
                <input type="range" id="animation-slider" min="0" max="0" value="0">
                
                <!-- Main Animation Controls -->
                <div class="animation-main-controls">
                    <button id="prev-frame" class="control-btn step-btn" title="Previous Frame">⏮</button>
                    <button id="play-pause" class="control-btn play-btn" title="Play/Pause">▶</button>
                    <button id="next-frame" class="control-btn step-btn" title="Next Frame">⏭</button>
                </div>
                
                <!-- Playback Direction Controls -->
                <div class="direction-label">Direction</div>
                <div class="animation-direction-controls">
                    <button id="play-backward" class="control-btn direction-btn" title="Play Backward">&lt;&lt;</button>
                    <button id="play-forward" class="control-btn direction-btn" title="Play Forward">&gt;&gt;</button>
                </div>
                
                <!-- Speed Control -->
                <div class="slider-container">
                    <label for="animation-speed">Speed: <span id="animation-speed-value">1.0</span>x</label>
                    <input type="range" id="animation-speed" min="0.1" max="5.0" step="0.1" value="1.0">
                </div>
                
                <!-- Download Controls -->
                <div class="animation-download-controls">
                    <button id="download-animation" class="control-btn download-btn" title="Download Animation">📥 Download</button>
                    <div id="download-options" class="download-options" style="display: none;">
                        <button id="download-mp4" class="download-option">Video (WebM/MP4)</button>
                        <button id="download-gif" class="download-option">Frame ZIP</button>
                    </div>
                </div>
            </div>
            </div>
        </div>

        <div id="file-list-panel">
             <div id="file-list-header">
                <div id="file-list-header-left">
                    <h3>Loaded Files</h3>
                </div>
                <div id="file-list-header-right">
                    <button id="download-all-files" title="Download All Files as ZIP" style="display: none;">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 15.5l-3.5-3.5h2.5v-6h2v6h2.5l-3.5 3.5zm7.5 3.5h-15v-2h15v2z"/>
                        </svg>
                    </button>
                    <button id="toggle-file-list" title="Collapse File List">[−]</button>
                </div>
            </div>
            <div id="file-history">No files loaded.</div>
        </div>

        <div id="loading">Loading...</div>
        <div id="viewer-container"></div>
        <div id="dual-session-container">
            <div class="dual-viewers">
                <div class="dual-viewer-panel">
                    <div class="dual-viewer-header" id="left-viewer-header">Original Structure</div>
                    <div class="dual-viewer-content" id="left-viewer"></div>
                </div>
                <div class="dual-viewer-panel">
                    <div class="dual-viewer-header" id="right-viewer-header">Predicted Structure</div>
                    <div class="dual-viewer-content" id="right-viewer"></div>
                </div>
            </div>
        </div>
        <div id="grid-container">
            <div id="grid-content" class="grid-view"></div>
        </div>
    </div>

    <script>
        // VSCode API for communication
        const vscode = acquireVsCodeApi();
        
        // VSCode Integration Functions
        function requestPDBFiles() {
            vscode.postMessage({
                command: 'requestPDBFiles'
            });
        }
        
        function requestFolder() {
            vscode.postMessage({
                command: 'requestFolder'
            });
        }
        
        // requestFASTA function removed - use FASTA upload in Seq Alignment section instead
        
        // Toggle download options visibility
        function toggleDownloadOptions() {
            const options = document.getElementById('download-options');
            const isVisible = options.style.display === 'flex';
            options.style.display = isVisible ? 'none' : 'flex';
        }
        
        // Download animation functionality - fixed to use VSCode save dialog
        async function downloadAnimation(format) {
            if (diffusionSteps.length === 0) {
                vscode.postMessage({
                    command: 'showError',
                    message: 'No diffusion sequence loaded to download'
                });
                return;
            }
            
            const downloadBtn = document.getElementById('download-animation');
            const originalText = downloadBtn.textContent;
            downloadBtn.textContent = 'Recording...';
            downloadBtn.disabled = true;
            
            try {
                if (format === 'mp4') {
                    await recordMP4Animation();
                } else if (format === 'gif') {
                    await recordGIFAnimation();
                }
                
                // Show success message briefly
                downloadBtn.textContent = 'Downloaded!';
                setTimeout(() => {
                    downloadBtn.textContent = originalText;
                }, 1500);
                
            } catch (error) {
                console.error('Error recording animation:', error);
                vscode.postMessage({
                    command: 'showError',
                    message: 'Error recording animation: ' + error.message
                });
                downloadBtn.textContent = originalText;
            } finally {
                downloadBtn.disabled = false;
                toggleDownloadOptions(); // Hide options after download
            }
        }
        
        // Record MP4 animation - fixed to use VSCode save dialog
        async function recordMP4Animation() {
            const canvas = document.querySelector('#viewer-container canvas');
            if (!canvas) {
                throw new Error('No canvas found for recording');
            }
            
            // Try different mime types for better compatibility and quality
            const mimeTypes = [
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8',
                'video/webm',
                'video/mp4'
            ];
            
            let selectedMimeType = null;
            for (const mimeType of mimeTypes) {
                if (MediaRecorder.isTypeSupported(mimeType)) {
                    selectedMimeType = mimeType;
                    break;
                }
            }
            
            if (!selectedMimeType) {
                throw new Error('No supported video format found in this browser');
            }
            
            const stream = canvas.captureStream(60); // Higher FPS for better quality
            const recorder = new MediaRecorder(stream, { 
                mimeType: selectedMimeType,
                videoBitsPerSecond: 8000000 // 8 Mbps for better quality
            });
            const chunks = [];
            
            recorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    chunks.push(event.data);
                }
            };
            
            return new Promise((resolve, reject) => {
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: selectedMimeType });
                    
                    // Convert blob to base64 for VSCode
                    const reader = new FileReader();
                    reader.onload = function() {
                        const base64Data = reader.result.split(',')[1]; // Remove data:video/webm;base64, prefix
                        
                        // Determine file extension based on mime type
                        let extension = 'webm';
                        if (selectedMimeType.includes('mp4')) {
                            extension = 'mp4';
                        }
                        
                        // Send to VSCode for saving
                        vscode.postMessage({
                            command: 'downloadVideoFile',
                            data: base64Data,
                            filename: `diffusion_animation_${Date.now()}.${extension}`,
                            mimeType: selectedMimeType
                        });
                        
                        resolve();
                    };
                    reader.readAsDataURL(blob);
                };
                
                recorder.onerror = reject;
                recorder.start();
                
                // Record animation by stepping through frames
                recordAnimationFrames(recorder);
            });
        }
        
        // Record GIF animation using canvas frames
        async function recordGIFAnimation() {
            // Use a client-side GIF creation approach to avoid CORS issues
            const canvas = document.querySelector('#viewer-container canvas');
            if (!canvas) {
                throw new Error('No canvas found for recording');
            }
            
            // Create a simple GIF encoder without external workers
            const frames = [];
            const frameDelay = Math.max(1000 / (5 * animationSpeed), 100); // Min 100ms delay
            
            // Capture all frames first
            for (let frameIndex = 0; frameIndex < diffusionSteps.length; frameIndex++) {
                displayDiffusionStep(frameIndex, true);
                await new Promise(resolve => setTimeout(resolve, 100)); // Wait for rendering
                
                // Convert canvas to image data
                const imageData = canvas.toDataURL('image/png');
                frames.push(imageData);
            }
            
            // Create ZIP using VSCode save dialog
            if (frames.length > 0) {
                const zip = await createFrameZip(frames);
                
                // Convert ZIP blob to base64 for VSCode
                const reader = new FileReader();
                reader.onload = function() {
                    const base64Data = reader.result.split(',')[1]; // Remove data:application/zip;base64, prefix
                    
                    // Send to VSCode for saving
                    vscode.postMessage({
                        command: 'downloadZipFile',
                        data: base64Data,
                        filename: `diffusion_frames_${Date.now()}.zip`
                    });
                };
                reader.readAsDataURL(zip);
            }
        }
        
        // Create a ZIP file with all frames
        async function createFrameZip(frames) {
            // Import JSZip library dynamically
            if (typeof JSZip === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
                document.head.appendChild(script);
                
                await new Promise((resolve, reject) => {
                    script.onload = resolve;
                    script.onerror = () => reject(new Error('Failed to load JSZip library'));
                });
            }
            
            const zip = new JSZip();
            
            frames.forEach((frame, index) => {
                // Convert data URL to blob
                const byteString = atob(frame.split(',')[1]);
                const mimeString = frame.split(',')[0].split(':')[1].split(';')[0];
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }
                const blob = new Blob([ab], {type: mimeString});
                
                zip.file(`frame_${String(index).padStart(4, '0')}.png`, blob);
            });
            
            return await zip.generateAsync({type: 'blob'});
        }
        
        // Record animation frames for MP4
        function recordAnimationFrames(recorder) {
            let frameIndex = 0;
            const frameDelay = Math.max(1000 / (5 * animationSpeed), 50); // Min 50ms delay
            
            const nextFrame = () => {
                if (frameIndex >= diffusionSteps.length) {
                    // Add a small delay before stopping to ensure last frame is captured
                    setTimeout(() => recorder.stop(), 200);
                    return;
                }
                
                displayDiffusionStep(frameIndex, true);
                frameIndex++;
                
                setTimeout(nextFrame, frameDelay);
            };
            
            nextFrame();
        }
        
        // Listen for messages from VSCode
        window.addEventListener('message', async event => {
            const message = event.data;
            switch (message.command) {
                case 'loadPDBFiles':
                    await handleVSCodePDBFiles(message.files);
                    break;
                case 'loadFolder':
                    await handleVSCodeFolder(message.files);
                    break;
                case 'loadFASTA':
                    handleVSCodeFASTA(message.content);
                    break;
                case 'loadAccession':
                    await handleVSCodeAccession(message.accession);
                    break;
                case 'clearFiles':
                    clearAllFiles();
                    break;
            }
        });
        
        // Handle PDB files from VSCode
        async function handleVSCodePDBFiles(files) {
            const loadingIndicator = document.getElementById('loading');
            loadingIndicator.textContent = `Loading ${files.length} file(s)...`;
            loadingIndicator.style.display = 'block';
            
            // Wait for viewer to be ready before processing files
            if (!viewer) {
                loadingIndicator.textContent = 'Initializing viewer...';
                let retries = 0;
                while (!viewer && retries < 100) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                    retries++;
                }
                
                if (!viewer) {
                    loadingIndicator.textContent = 'Failed to initialize viewer';
                    loadingIndicator.style.display = 'none';
                    vscode.postMessage({
                        command: 'showError',
                        message: 'Viewer not ready. Please try again in a moment.'
                    });
                    return;
                }
                
                loadingIndicator.textContent = `Loading ${files.length} file(s)...`;
            }
            
            try {
                let firstNewFileName = null;
                
                files.forEach(file => {
                    if (!firstNewFileName) {
                        firstNewFileName = file.name;
                    }
                    
                    // Determine format
                    let format = 'pdb';
                    const fileName = file.name.toLowerCase();
                    if (fileName.endsWith('.pdb')) {
                        format = 'pdb';
                    } else if (fileName.endsWith('.cif') || fileName.endsWith('.mmcif')) {
                        format = 'mmcif';
                    } else if (fileName.endsWith('.pdbqt')) {
                        format = 'pdbqt';
                    } else if (fileName.endsWith('.gro')) {
                        format = 'gro';
                    } else if (fileName.endsWith('.xyz')) {
                        format = 'xyz';
                    } else if (fileName.endsWith('.mol')) {
                        format = 'mol';
                    } else if (fileName.endsWith('.mol2')) {
                        format = 'mol2';
                    } else if (fileName.endsWith('.sdf')) {
                        format = 'sdf';
                    }
                    
                    loadedFiles.push({
                        name: file.name,
                        data: file.content,
                        format: format,
                        source: 'local'
                    });
                });
                
                // Sort files naturally
                loadedFiles.sort((a, b) => naturalSort(a.name, b.name));
                
                // Find and display first file
                currentFileIndex = loadedFiles.findIndex(f => f.name === firstNewFileName);
                if (currentFileIndex === -1 && loadedFiles.length > 0) {
                    currentFileIndex = 0;
                }
                
                if (currentFileIndex !== -1) {
                    parseStructureFile(
                        loadedFiles[currentFileIndex].data,
                        loadedFiles[currentFileIndex].format,
                        false
                    );
                }
                
                updateFileHistory();
                updateReferenceStructureDropdown(); // Update alignment dropdown
                document.getElementById('animation-controls').style.display = 'none';
                stopAnimation();
                
            } catch (error) {
                console.error("Error loading files from VSCode:", error);
                vscode.postMessage({
                    command: 'showError',
                    message: 'Error loading files: ' + error.message
                });
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Handle folder from VSCode
        async function handleVSCodeFolder(files) {
            const loadingIndicator = document.getElementById('loading');
            loadingIndicator.textContent = 'Loading diffusion sequence...';
            loadingIndicator.style.display = 'block';
            
            // Wait for viewer to be ready before processing files
            if (!viewer) {
                loadingIndicator.textContent = 'Initializing viewer...';
                let retries = 0;
                while (!viewer && retries < 100) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                    retries++;
                }
                
                if (!viewer) {
                    loadingIndicator.textContent = 'Failed to initialize viewer';
                    loadingIndicator.style.display = 'none';
                    vscode.postMessage({
                        command: 'showError',
                        message: 'Viewer not ready. Please try again in a moment.'
                    });
                    return;
                }
                
                loadingIndicator.textContent = 'Loading diffusion sequence...';
            }
            
            try {
                diffusionSteps = [];
                stopAnimation();
                
                files.forEach(file => {
                    // Determine format
                    let format = 'pdb';
                    const fileName = file.name.toLowerCase();
                    if (fileName.endsWith('.pdb')) {
                        format = 'pdb';
                    } else if (fileName.endsWith('.cif') || fileName.endsWith('.mmcif')) {
                        format = 'mmcif';
                    } else if (fileName.endsWith('.pdbqt')) {
                        format = 'pdbqt';
                    } else if (fileName.endsWith('.gro')) {
                        format = 'gro';
                    } else if (fileName.endsWith('.xyz')) {
                        format = 'xyz';
                    } else if (fileName.endsWith('.mol')) {
                        format = 'mol';
                    } else if (fileName.endsWith('.mol2')) {
                        format = 'mol2';
                    } else if (fileName.endsWith('.sdf')) {
                        format = 'sdf';
                    }
                    
                    const stepMatch = file.name.match(/(\d+)/);
                    const stepNum = stepMatch ? parseInt(stepMatch[1]) : diffusionSteps.length;
                    
                    diffusionSteps.push({
                        name: file.name,
                        step: stepNum,
                        data: file.content,
                        format: format
                    });
                    
                    // Add to main list if not already present
                    if (!loadedFiles.some(f => f.name === file.name)) {
                        loadedFiles.push({
                            name: file.name,
                            data: file.content,
                            format: format,
                            source: 'local'
                        });
                    }
                });
                
                if (diffusionSteps.length > 0) {
                    // Sort diffusion steps by step number
                    diffusionSteps.sort((a, b) => a.step - b.step);
                    
                    // Sort main files list
                    loadedFiles.sort((a, b) => naturalSort(a.name, b.name));
                    
                    // Find and display first step
                    currentFileIndex = loadedFiles.findIndex(f => f.name === diffusionSteps[0].name);
                    if (currentFileIndex === -1) {
                        currentFileIndex = 0;
                    }
                    
                    currentStepIndex = 0;
                    displayDiffusionStep(currentStepIndex, false);
                    
                    updateFileHistory();
                    updateReferenceStructureDropdown(); // Update alignment dropdown
                    initializeAnimationControls();
                }
                
            } catch (error) {
                console.error("Error loading folder from VSCode:", error);
                vscode.postMessage({
                    command: 'showError',
                    message: 'Error loading folder: ' + error.message
                });
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Handle FASTA from VSCode
        function handleVSCodeFASTA(content) {
            // Auto-enable sequence alignment when loading FASTA from VSCode
            const alignmentToggle = document.getElementById('seq-alignment-toggle');
            if (!alignmentToggle.checked) {
                alignmentToggle.checked = true;
                toggleSequenceAlignment();
            }
            
            document.getElementById('fasta-textarea').value = content;
            parseFastaInput();
        }
        
        // Handle accession from VSCode
        async function handleVSCodeAccession(accession) {
            const loadingIndicator = document.getElementById('loading');
            loadingIndicator.textContent = `Loading ${accession}...`;
            loadingIndicator.style.display = 'block';
            
            try {
                // Clear any existing files
                loadedFiles = [];
                currentFileIndex = -1;
                
                // Wait for viewer to be ready before processing
                if (!viewer) {
                    loadingIndicator.textContent = 'Initializing viewer...';
                    let retries = 0;
                    while (!viewer && retries < 100) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                        retries++;
                    }
                    if (!viewer) {
                        throw new Error('Viewer failed to initialize');
                    }
                }
                
                // Clear viewer first
                await viewer.plugin.clear();
                
                let structureData;
                let format = 'pdb';
                
                // Determine if it's PDB (4 characters) or AlphaFold (longer)
                if (accession.length === 4) {
                    // PDB ID
                    loadingIndicator.textContent = `Fetching PDB ${accession}...`;
                    const response = await fetch(`https://files.rcsb.org/download/${accession}.pdb`);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch PDB ${accession}: ${response.status}`);
                    }
                    structureData = await response.text();
                } else {
                    // AlphaFold DB (UniProt ID)
                    loadingIndicator.textContent = `Fetching AlphaFold ${accession}...`;
                    const response = await fetch(`https://alphafold.ebi.ac.uk/files/AF-${accession}-F1-model_v4.pdb`);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch AlphaFold ${accession}: ${response.status}`);
                    }
                    structureData = await response.text();
                }
                
                // Validate structure data
                if (!structureData || structureData.trim().length === 0) {
                    throw new Error('Empty structure data received');
                }
                
                // Add to loaded files
                loadedFiles.push({
                    name: `${accession}.pdb`,
                    data: structureData,
                    format: format,
                    source: 'remote' // Mark as remote (PDB/AlphaFold)
                });
                
                currentFileIndex = 0;
                
                // Parse and display the structure
                parseStructureFile(structureData, format, false);
                
                // Set color mode to chain for fetched PDB/AFDB structures
                await changeColorMode('chain');
                
                // Update UI
                updateFileHistory();
                document.getElementById('animation-controls').style.display = 'none';
                stopAnimation();
                
                console.log(`Successfully loaded ${accession}`);
                
            } catch (error) {
                console.error("Error loading accession:", error);
                vscode.postMessage({
                    command: 'showError',
                    message: `Error loading ${accession}: ${error.message}`
                });
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Clear all files
        function clearAllFiles() {
            loadedFiles = [];
            diffusionSteps = [];
            currentFileIndex = -1;
            currentStepIndex = 0;
            stopAnimation();
            
            if (viewer) {
                viewer.plugin.clear();
            }
            
            updateFileHistory();
            updateReferenceStructureDropdown();
            document.getElementById('animation-controls').style.display = 'none';
            document.getElementById('atom-count').textContent = '0';
        }
        
        // Main variables for 3DMol.js
        let viewer;
        // Sphere variables removed - using cartoon mode only
        // Cartoon thickness and opacity controls removed
        let loadedFiles = [];
        let currentFileIndex = -1;
        let diffusionSteps = [];
        let currentStepIndex = 0;
        let isPlaying = false;
        let playDirection = 1;
        let animationSpeed = 1.0;
        let animationTimer = null;
        // View mode fixed to cartoon only
        let currentColorMode = 'custom'; // 'custom', 'element', 'residue', 'chain', 'rainbow'
        let currentCustomColor = '#4ECDC4'; // Default teal color
        let currentRainbowPalette = 'rainbow'; // Current rainbow palette selection
        let illustrativeStyleEnabled = false; // Illustrative style toggle
        let currentModels = []; // Store current 3DMol models
        let currentLayoutMode = 'single'; // 'single' or 'grid'
        let gridViewers = []; // Store grid viewers
        let expandedGridItem = null; // Track expanded grid item
        let activeGridViewers = new Set(); // Track which grid viewers are active
        let gridPreviewImages = []; // Store preview images for grid items
        let gridViewerOrder = []; // Track order of activation for LRU management

        // Rainbow color palettes
        const RAINBOW_PALETTES = {
            'rainbow': ['#0000FF', '#00FFFF', '#00FF00', '#FFFF00', '#FF8000', '#FF0000'],
            'viridis': ['#440154', '#482878', '#3e4989', '#31688e', '#26828e', '#1f9e89', '#35b779', '#6ece58', '#b5de2b', '#fde724'],
            'plasma': ['#0d0887', '#46039f', '#7201a8', '#9c179e', '#bd3786', '#d8576b', '#ed7953', '#fb9f3a', '#fdca26', '#f0f921'],
            'magma': ['#000004', '#1c1044', '#4f127b', '#812581', '#b5367a', '#e55964', '#fb8861', '#fec287', '#fcfdbf'],
            'blue-red': ['#0000FF', '#FF0000'],
            'pastel': ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E0BBE4']
        };

        // Color interpolation helper functions
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        function interpolateColor(color1, color2, factor) {
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            if (!c1 || !c2) return color1;

            const r = Math.round(c1.r + factor * (c2.r - c1.r));
            const g = Math.round(c1.g + factor * (c2.g - c1.g));
            const b = Math.round(c1.b + factor * (c2.b - c1.b));
            return rgbToHex(r, g, b);
        }

        function generateGradient(colors, steps) {
            if (steps <= 0) return [];
            if (steps === 1) return [colors[0]];
            if (colors.length === 0) return [];
            if (colors.length === 1) return Array(steps).fill(colors[0]);

            const gradient = [];
            const segmentCount = colors.length - 1;
            const stepsPerSegment = (steps - 1) / segmentCount;

            for (let i = 0; i < steps; i++) {
                const position = i / (steps - 1) * segmentCount;
                const segmentIndex = Math.floor(position);
                const segmentPosition = position - segmentIndex;

                if (segmentIndex >= segmentCount) {
                    gradient.push(colors[colors.length - 1]);
                } else {
                    const color = interpolateColor(
                        colors[segmentIndex],
                        colors[segmentIndex + 1],
                        segmentPosition
                    );
                    gradient.push(color);
                }
            }

            return gradient;
        }

        function hexToMolstarColor(hex) {
            return parseInt(hex.replace('#', ''), 16);
        }
        
        // Structure alignment variables
        let alignmentData = null; // Store alignment results
        let alignedStructures = []; // Store aligned structure data
        let structureVisibility = new Map(); // Track structure visibility
        
        // Sequence alignment variables
        let sequenceAlignmentEnabled = false;
        let currentInputMode = 'fasta'; // 'fasta' or 'single'
        let parsedSequences = []; // Array of parsed sequences
        let selectedSequenceIndex = -1;
        let currentDisplayMode = 'dual'; // 'dual', 'seq-only', or 'align'
        let sequenceStructures = []; // Store structures for each sequence
        let predictedStructureIds = new Set(); // Track which structures are predicted (should keep pLDDT coloring)
        
        // Dual session variables
        let leftViewer = null; // Viewer for original structure
        let rightViewer = null; // Viewer for predicted structure
        let currentSessionMode = 'single'; // 'single', 'dual', 'align'
        
        // Color palettes
        const customColors = {
            '#4ECDC4': 'teal',
            '#FF6B6B': 'red',
            '#4DABF7': 'blue', 
            '#69DB7C': 'green',
            '#FFD93D': 'yellow',
            '#FF922B': 'orange',
            '#DA77F2': 'purple',
            '#FF8CC8': 'pink',
            '#15AABF': 'cyan',
            '#868E96': 'gray'
        };

        // --- Natural Sort Function ---
        function naturalSort(a, b) {
            const ax = [], bx = [];
            a.replace(/(\d+)|(\D+)/g, function(_, $1, $2) { ax.push([$1 || Infinity, $2 || ""]) });
            b.replace(/(\d+)|(\D+)/g, function(_, $1, $2) { bx.push([$1 || Infinity, $2 || ""]) });
            while(ax.length && bx.length) {
                const an = ax.shift();
                const bn = bx.shift();
                const nn = (an[0] - bn[0]) || an[1].localeCompare(bn[1]);
                if(nn) return nn;
            }
            return ax.length - bx.length;
        }

        // ========== Structure Alignment Functions ==========
        
        // Extract sequence from PDB file
        function extractSequenceFromPDB(pdbContent) {
            const lines = pdbContent.split('\n');
            const residueMap = new Map(); // Map (chain, residueNumber) to residue name
            
            // Standard amino acids only (exclude water, ions, ligands, etc.)
            const standardAminoAcids = {
                'ALA': 'A', 'ARG': 'R', 'ASN': 'N', 'ASP': 'D', 'CYS': 'C',
                'GLN': 'Q', 'GLU': 'E', 'GLY': 'G', 'HIS': 'H', 'ILE': 'I',
                'LEU': 'L', 'LYS': 'K', 'MET': 'M', 'PHE': 'F', 'PRO': 'P',
                'SER': 'S', 'THR': 'T', 'TRP': 'W', 'TYR': 'Y', 'VAL': 'V',
                'ASX': 'B', 'GLX': 'Z', 'XAA': 'X', 'UNK': 'X'
            };
            
            // Only process ATOM records (not HETATM) and only standard amino acids
            for (const line of lines) {
                if (line.startsWith('ATOM')) { // Only ATOM, not HETATM
                    const residueName = line.substring(17, 20).trim();
                    const residueNumber = parseInt(line.substring(22, 26).trim());
                    const chainId = (line.substring(21, 22).trim() || 'A');
                    
                    // Only include standard amino acids
                    if (!isNaN(residueNumber) && residueName && standardAminoAcids.hasOwnProperty(residueName)) {
                        const key = `${chainId}_${residueNumber}`;
                        if (!residueMap.has(key)) {
                            residueMap.set(key, { name: residueName, number: residueNumber, chain: chainId });
                        }
                    }
                }
            }
            
            // Sort by chain, then by residue number (matching CA atom extraction order)
            const sortedResidues = Array.from(residueMap.values()).sort((a, b) => {
                if (a.chain !== b.chain) {
                    return (a.chain || 'A').localeCompare(b.chain || 'A');
                }
                return a.number - b.number;
            });
            
            const sequence = [];
            for (const data of sortedResidues) {
                const oneLetter = standardAminoAcids[data.name] || 'X';
                sequence.push({ residue: oneLetter, number: data.number, chain: data.chain, name: data.name });
            }
            
            return sequence;
        }
        
        // Extract sequence from mmCIF file
        function extractSequenceFromCIF(cifContent) {
            const lines = cifContent.split('\n');
            const sequence = [];
            const residueMap = new Map();
            let columnIndices = {};
            let inAtomSite = false;
            let headerFound = false;
            
            // Standard amino acids only (exclude water, ions, ligands, etc.)
            const standardAminoAcids = {
                'ALA': 'A', 'ARG': 'R', 'ASN': 'N', 'ASP': 'D', 'CYS': 'C',
                'GLN': 'Q', 'GLU': 'E', 'GLY': 'G', 'HIS': 'H', 'ILE': 'I',
                'LEU': 'L', 'LYS': 'K', 'MET': 'M', 'PHE': 'F', 'PRO': 'P',
                'SER': 'S', 'THR': 'T', 'TRP': 'W', 'TYR': 'Y', 'VAL': 'V',
                'ASX': 'B', 'GLX': 'Z', 'XAA': 'X', 'UNK': 'X'
            };
            
            // First pass: find column indices
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('_atom_site.')) {
                    inAtomSite = true;
                    const fieldName = line.split('.')[1].split(/\s+/)[0];
                    columnIndices[fieldName] = Object.keys(columnIndices).length;
                    continue;
                }
                if (inAtomSite && line && !line.startsWith('#') && !headerFound) {
                    // First data line - we now know the column order
                    headerFound = true;
                    break;
                }
            }
            
            // Second pass: extract data
            if (headerFound && inAtomSite) {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.startsWith('_atom_site.') || line.startsWith('#') || !line) continue;
                    
                    // Check if we're past the header
                    if (inAtomSite && headerFound) {
                        const fields = line.split(/\s+/).filter(f => f.length > 0);
                        if (fields.length > 0) {
                            const groupPdbIdx = columnIndices['group_PDB']; // 'ATOM' or 'HETATM'
                            const labelCompIdIdx = columnIndices['label_comp_id'];
                            const labelSeqIdIdx = columnIndices['label_seq_id'];
                            const labelAsymIdIdx = columnIndices['label_asym_id'];
                            
                            // Only process ATOM records (not HETATM) and only standard amino acids
                            const isAtom = groupPdbIdx !== undefined ? fields[groupPdbIdx] === 'ATOM' : true;
                            
                            if (isAtom && labelCompIdIdx !== undefined && labelSeqIdIdx !== undefined) {
                                const residueName = fields[labelCompIdIdx];
                                const residueNumber = parseInt(fields[labelSeqIdIdx]);
                                const chainId = labelAsymIdIdx !== undefined ? fields[labelAsymIdIdx] : 'A';
                                
                                // Only include standard amino acids
                                if (!isNaN(residueNumber) && residueName && standardAminoAcids.hasOwnProperty(residueName)) {
                                    const key = `${chainId}_${residueNumber}`;
                                    if (!residueMap.has(key)) {
                                        residueMap.set(key, { name: residueName, number: residueNumber, chain: chainId });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            const sortedResidues = Array.from(residueMap.values()).sort((a, b) => {
                if (a.chain !== b.chain) return a.chain.localeCompare(b.chain);
                return a.number - b.number;
            });
            
            for (const data of sortedResidues) {
                const oneLetter = standardAminoAcids[data.name] || 'X';
                sequence.push({ residue: oneLetter, number: data.number, chain: data.chain, name: data.name });
            }
            
            return sequence;
        }
        
        // Needleman-Wunsch global sequence alignment
        function needlemanWunsch(seq1, seq2, matchScore = 1, mismatchScore = -1, gapPenalty = -1) {
            const n = seq1.length;
            const m = seq2.length;
            
            // Initialize scoring matrix
            const score = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));
            const traceback = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));
            
            // Initialize first row and column
            for (let i = 1; i <= n; i++) {
                score[i][0] = i * gapPenalty;
                traceback[i][0] = 1; // Up
            }
            for (let j = 1; j <= m; j++) {
                score[0][j] = j * gapPenalty;
                traceback[0][j] = 2; // Left
            }
            
            // Fill scoring matrix
            for (let i = 1; i <= n; i++) {
                for (let j = 1; j <= m; j++) {
                    const match = (seq1[i - 1] === seq2[j - 1]) ? matchScore : mismatchScore;
                    const diag = score[i - 1][j - 1] + match;
                    const up = score[i - 1][j] + gapPenalty;
                    const left = score[i][j - 1] + gapPenalty;
                    
                    const max = Math.max(diag, up, left);
                    score[i][j] = max;
                    
                    if (max === diag) {
                        traceback[i][j] = 0; // Diagonal
                    } else if (max === up) {
                        traceback[i][j] = 1; // Up
                    } else {
                        traceback[i][j] = 2; // Left
                    }
                }
            }
            
            // Traceback
            let i = n, j = m;
            const aligned1 = [];
            const aligned2 = [];
            
            while (i > 0 || j > 0) {
                if (traceback[i][j] === 0) {
                    aligned1.unshift(seq1[i - 1]);
                    aligned2.unshift(seq2[j - 1]);
                    i--;
                    j--;
                } else if (traceback[i][j] === 1) {
                    aligned1.unshift(seq1[i - 1]);
                    aligned2.unshift('-');
                    i--;
                } else {
                    aligned1.unshift('-');
                    aligned2.unshift(seq2[j - 1]);
                    j--;
                }
            }
            
            return {
                aligned1: aligned1.join(''),
                aligned2: aligned2.join(''),
                score: score[n][m]
            };
        }
        
        // Smith-Waterman local sequence alignment
        // Returns the best local alignment and the region boundaries in both sequences
        function smithWaterman(seq1, seq2, matchScore = 2, mismatchScore = -1, gapPenalty = -1) {
            const n = seq1.length;
            const m = seq2.length;
            
            // Initialize scoring matrix (all zeros for local alignment)
            const score = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));
            const traceback = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));
            
            let maxScore = 0;
            let maxI = 0;
            let maxJ = 0;
            
            // Fill scoring matrix
            for (let i = 1; i <= n; i++) {
                for (let j = 1; j <= m; j++) {
                    const match = (seq1[i - 1] === seq2[j - 1]) ? matchScore : mismatchScore;
                    const diag = Math.max(0, score[i - 1][j - 1] + match);
                    const up = Math.max(0, score[i - 1][j] + gapPenalty);
                    const left = Math.max(0, score[i][j - 1] + gapPenalty);
                    
                    const max = Math.max(0, diag, up, left);
                    score[i][j] = max;
                    
                    // Track maximum score position
                    if (max > maxScore) {
                        maxScore = max;
                        maxI = i;
                        maxJ = j;
                    }
                    
                    if (max === 0) {
                        traceback[i][j] = -1; // Stop (no alignment)
                    } else if (max === diag) {
                        traceback[i][j] = 0; // Diagonal
                    } else if (max === up) {
                        traceback[i][j] = 1; // Up
                    } else {
                        traceback[i][j] = 2; // Left
                    }
                }
            }
            
            // Traceback from maximum score position
            let i = maxI;
            let j = maxJ;
            const aligned1 = [];
            const aligned2 = [];
            const refIndices = []; // Track indices in seq1
            const queryIndices = []; // Track indices in seq2
            
            // Traceback until we hit a score of 0
            while (i > 0 && j > 0 && score[i][j] > 0) {
                const tb = traceback[i][j];
                
                if (tb === 0) {
                    // Diagonal (match/mismatch)
                    aligned1.unshift(seq1[i - 1]);
                    aligned2.unshift(seq2[j - 1]);
                    refIndices.unshift(i - 1); // Store 0-based index
                    queryIndices.unshift(j - 1); // Store 0-based index
                    i--;
                    j--;
                } else if (tb === 1) {
                    // Up (gap in seq2)
                    aligned1.unshift(seq1[i - 1]);
                    aligned2.unshift('-');
                    refIndices.unshift(i - 1);
                    queryIndices.unshift(-1); // Gap in query
                    i--;
                } else if (tb === 2) {
                    // Left (gap in seq1)
                    aligned1.unshift('-');
                    aligned2.unshift(seq2[j - 1]);
                    refIndices.unshift(-1); // Gap in reference
                    queryIndices.unshift(j - 1);
                    j--;
                } else {
                    // Stop condition (score is 0 or invalid traceback)
                    break;
                }
            }
            
            // Find the boundaries of the aligned region (without leading/trailing gaps)
            let alignedStart1 = -1, alignedEnd1 = -1;
            let alignedStart2 = -1, alignedEnd2 = -1;
            
            for (let idx = 0; idx < aligned1.length; idx++) {
                if (aligned1[idx] !== '-') {
                    if (alignedStart1 === -1) alignedStart1 = refIndices[idx];
                    alignedEnd1 = refIndices[idx];
                }
                if (aligned2[idx] !== '-') {
                    if (alignedStart2 === -1) alignedStart2 = queryIndices[idx];
                    alignedEnd2 = queryIndices[idx];
                }
            }
            
            return {
                aligned1: aligned1.join(''),
                aligned2: aligned2.join(''),
                score: maxScore,
                refStart: alignedStart1,
                refEnd: alignedEnd1,
                queryStart: alignedStart2,
                queryEnd: alignedEnd2,
                refIndices: refIndices,
                queryIndices: queryIndices
            };
        }
        
        // Extract CA atoms from PDB
        function extractCAAtoms(pdbContent) {
            const lines = pdbContent.split('\n');
            const atoms = [];
            const atomMap = new Map(); // Use map to handle duplicate residue numbers
            
            for (const line of lines) {
                if (line.startsWith('ATOM') && line.substring(12, 16).trim() === 'CA') {
                    const x = parseFloat(line.substring(30, 38));
                    const y = parseFloat(line.substring(38, 46));
                    const z = parseFloat(line.substring(46, 54));
                    const residueNumber = parseInt(line.substring(22, 26).trim());
                    const chainId = line.substring(21, 22).trim() || 'A';
                    // B-factor is in columns 60-66 (0-indexed: 60-65)
                    const bFactor = parseFloat(line.substring(60, 66).trim());
                    
                    if (!isNaN(x) && !isNaN(y) && !isNaN(z) && !isNaN(residueNumber)) {
                        const key = `${chainId}_${residueNumber}`;
                        // Only add if we haven't seen this residue yet (handle duplicates)
                        if (!atomMap.has(key)) {
                            atomMap.set(key, {
                                x, y, z,
                                residueNumber,
                                chainId,
                                bFactor: isNaN(bFactor) ? null : bFactor  // null if B-factor not available
                            });
                        }
                    }
                }
            }
            
            // Sort by chain, then by residue number (matching sequence extraction order)
            const sortedAtoms = Array.from(atomMap.values()).sort((a, b) => {
                if (a.chainId !== b.chainId) {
                    return (a.chainId || 'A').localeCompare(b.chainId || 'A');
                }
                return a.residueNumber - b.residueNumber;
            });
            
            return sortedAtoms;
        }
        
        // Extract CA atoms from mmCIF
        function extractCAAtomsFromCIF(cifContent) {
            const lines = cifContent.split('\n');
            const atoms = [];
            let columnIndices = {};
            let inAtomSite = false;
            let headerFound = false;
            
            // First pass: find column indices
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('_atom_site.')) {
                    inAtomSite = true;
                    const fieldName = line.split('.')[1].split(/\s+/)[0];
                    columnIndices[fieldName] = Object.keys(columnIndices).length;
                    continue;
                }
                if (inAtomSite && line && !line.startsWith('#') && !headerFound) {
                    headerFound = true;
                    break;
                }
            }
            
            // Second pass: extract CA atoms
            if (headerFound && inAtomSite) {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.startsWith('_atom_site.') || line.startsWith('#') || !line) continue;
                    
                    if (inAtomSite && headerFound) {
                        const fields = line.split(/\s+/).filter(f => f.length > 0);
                        if (fields.length > 0) {
                            const labelAtomIdIdx = columnIndices['label_atom_id'];
                            const labelSeqIdIdx = columnIndices['label_seq_id'];
                            const labelAsymIdIdx = columnIndices['label_asym_id'];
                            const CartnXIdx = columnIndices['Cartn_x'];
                            const CartnYIdx = columnIndices['Cartn_y'];
                            const CartnZIdx = columnIndices['Cartn_z'];
                            
                            if (labelAtomIdIdx !== undefined && fields[labelAtomIdIdx] === 'CA') {
                                if (CartnXIdx !== undefined && CartnYIdx !== undefined && CartnZIdx !== undefined && 
                                    labelSeqIdIdx !== undefined) {
                                    const x = parseFloat(fields[CartnXIdx]);
                                    const y = parseFloat(fields[CartnYIdx]);
                                    const z = parseFloat(fields[CartnZIdx]);
                                    const residueNumber = parseInt(fields[labelSeqIdIdx]);
                                    const chainId = labelAsymIdIdx !== undefined ? fields[labelAsymIdIdx] : 'A';
                                    
                                    // Try to extract B-factor (B_iso_or_equiv or B_iso)
                                    const bIsoIdx = columnIndices['B_iso_or_equiv'] !== undefined ? 
                                                   columnIndices['B_iso_or_equiv'] : columnIndices['B_iso'];
                                    let bFactor = null;
                                    if (bIsoIdx !== undefined && fields[bIsoIdx] !== undefined) {
                                        bFactor = parseFloat(fields[bIsoIdx]);
                                        if (isNaN(bFactor)) bFactor = null;
                                    }
                                    
                                    if (!isNaN(x) && !isNaN(y) && !isNaN(z) && !isNaN(residueNumber)) {
                                        atoms.push({ x, y, z, residueNumber, chainId, bFactor: bFactor });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Sort by chain and residue number
            atoms.sort((a, b) => {
                if (a.chainId !== b.chainId) return a.chainId.localeCompare(b.chainId);
                return a.residueNumber - b.residueNumber;
            });
            
            return atoms;
        }
        
        // Kabsch algorithm for optimal rotation matrix
        function kabschAlgorithm(P, Q) {
            // Center the point sets
            const n = P.length;
            const centroidP = { x: 0, y: 0, z: 0 };
            const centroidQ = { x: 0, y: 0, z: 0 };
            
            for (let i = 0; i < n; i++) {
                centroidP.x += P[i].x;
                centroidP.y += P[i].y;
                centroidP.z += P[i].z;
                centroidQ.x += Q[i].x;
                centroidQ.y += Q[i].y;
                centroidQ.z += Q[i].z;
            }
            
            centroidP.x /= n;
            centroidP.y /= n;
            centroidP.z /= n;
            centroidQ.x /= n;
            centroidQ.y /= n;
            centroidQ.z /= n;
            
            // Center the points
            const P_centered = P.map(p => ({
                x: p.x - centroidP.x,
                y: p.y - centroidP.y,
                z: p.z - centroidP.z
            }));
            const Q_centered = Q.map(q => ({
                x: q.x - centroidQ.x,
                y: q.y - centroidQ.y,
                z: q.z - centroidQ.z
            }));
            
            // Compute covariance matrix
            const H = [
                [0, 0, 0],
                [0, 0, 0],
                [0, 0, 0]
            ];
            
            for (let i = 0; i < n; i++) {
                H[0][0] += P_centered[i].x * Q_centered[i].x;
                H[0][1] += P_centered[i].x * Q_centered[i].y;
                H[0][2] += P_centered[i].x * Q_centered[i].z;
                H[1][0] += P_centered[i].y * Q_centered[i].x;
                H[1][1] += P_centered[i].y * Q_centered[i].y;
                H[1][2] += P_centered[i].y * Q_centered[i].z;
                H[2][0] += P_centered[i].z * Q_centered[i].x;
                H[2][1] += P_centered[i].z * Q_centered[i].y;
                H[2][2] += P_centered[i].z * Q_centered[i].z;
            }
            
            // SVD (simplified version - using Jacobi method approximation)
            // For simplicity, we'll use a basic rotation matrix calculation
            // In production, use a proper SVD library
            const R = computeRotationMatrix(H);
            
            return {
                rotation: R,
                translation: {
                    x: centroidQ.x - (R[0][0] * centroidP.x + R[0][1] * centroidP.y + R[0][2] * centroidP.z),
                    y: centroidQ.y - (R[1][0] * centroidP.x + R[1][1] * centroidP.y + R[1][2] * centroidP.z),
                    z: centroidQ.z - (R[2][0] * centroidP.x + R[2][1] * centroidP.y + R[2][2] * centroidP.z)
                }
            };
        }
        
        // Improved rotation matrix computation using SVD (for Kabsch)
        function computeRotationMatrix(H) {
            // Compute SVD of H using Jacobi method for 3x3 matrix
            // H = U * S * V^T, we want R = V * U^T
            
            // For 3x3 matrix, use analytical SVD
            const a = H[0][0], b = H[0][1], c = H[0][2];
            const d = H[1][0], e = H[1][1], f = H[1][2];
            const g = H[2][0], h = H[2][1], i = H[2][2];
            
            // Compute H^T * H for eigenvalue decomposition
            const HtH = [
                [a*a + d*d + g*g, a*b + d*e + g*h, a*c + d*f + g*i],
                [a*b + d*e + g*h, b*b + e*e + h*h, b*c + e*f + h*i],
                [a*c + d*f + g*i, b*c + e*f + h*i, c*c + f*f + i*i]
            ];
            
            // Use iterative Jacobi method for 3x3 SVD (simplified)
            // For better accuracy, we'll use a more direct approach
            
            // Compute determinant to check for reflection
            const det = a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
            
            // Use quaternion method with improved convergence
            const trace = a + e + i;
            const offDiag = b + c + d + f + g + h;
            
            // Construct 4x4 matrix for quaternion eigenvector
            const Q = [
                [trace, h - f, c - g, d - b],
                [h - f, a - e - i, b + d, c + g],
                [c - g, b + d, e - a - i, f + h],
                [d - b, c + g, f + h, i - a - e]
            ];
            
            // Power method with more iterations for better convergence
            let q = [1, 0, 0, 0];
            for (let iter = 0; iter < 50; iter++) {
                const qNew = [
                    Q[0][0]*q[0] + Q[0][1]*q[1] + Q[0][2]*q[2] + Q[0][3]*q[3],
                    Q[1][0]*q[0] + Q[1][1]*q[1] + Q[1][2]*q[2] + Q[1][3]*q[3],
                    Q[2][0]*q[0] + Q[2][1]*q[1] + Q[2][2]*q[2] + Q[2][3]*q[3],
                    Q[3][0]*q[0] + Q[3][1]*q[1] + Q[3][2]*q[2] + Q[3][3]*q[3]
                ];
                const norm = Math.sqrt(qNew[0]**2 + qNew[1]**2 + qNew[2]**2 + qNew[3]**2);
                if (norm < 1e-10) break;
                q = qNew.map(v => v / norm);
                
                // Check convergence
                if (iter > 10) {
                    const change = Math.abs(q[0] - qNew[0]/norm) + Math.abs(q[1] - qNew[1]/norm) + 
                                  Math.abs(q[2] - qNew[2]/norm) + Math.abs(q[3] - qNew[3]/norm);
                    if (change < 1e-6) break;
                }
            }
            
            // Convert quaternion to rotation matrix
            const [w, x, y, z] = q;
            const R = [
                [1 - 2*(y*y + z*z), 2*(x*y - w*z), 2*(x*z + w*y)],
                [2*(x*y + w*z), 1 - 2*(x*x + z*z), 2*(y*z - w*x)],
                [2*(x*z - w*y), 2*(y*z + w*x), 1 - 2*(x*x + y*y)]
            ];
            
            // Ensure proper rotation (det = 1) by correcting for reflection if needed
            const detR = R[0][0]*(R[1][1]*R[2][2] - R[1][2]*R[2][1]) - 
                        R[0][1]*(R[1][0]*R[2][2] - R[1][2]*R[2][0]) + 
                        R[0][2]*(R[1][0]*R[2][1] - R[1][1]*R[2][0]);
            
            if (detR < 0) {
                // Reflection detected, flip sign of last column
                R[0][2] = -R[0][2];
                R[1][2] = -R[1][2];
                R[2][2] = -R[2][2];
            }
            
            return R;
        }
        
        // Calculate RMSD
        function calculateRMSD(P, Q) {
            if (P.length !== Q.length) return Infinity;
            let sumSqDiff = 0;
            for (let i = 0; i < P.length; i++) {
                const dx = P[i].x - Q[i].x;
                const dy = P[i].y - Q[i].y;
                const dz = P[i].z - Q[i].z;
                sumSqDiff += dx*dx + dy*dy + dz*dz;
            }
            return Math.sqrt(sumSqDiff / P.length);
        }
        
        // Apply transformation to coordinates
        function applyTransformation(coords, rotation, translation) {
            return coords.map(coord => ({
                x: rotation[0][0] * coord.x + rotation[0][1] * coord.y + rotation[0][2] * coord.z + translation.x,
                y: rotation[1][0] * coord.x + rotation[1][1] * coord.y + rotation[1][2] * coord.z + translation.y,
                z: rotation[2][0] * coord.x + rotation[2][1] * coord.y + rotation[2][2] * coord.z + translation.z
            }));
        }
        
        // Multiply two 3x3 rotation matrices
        function multiplyMatrices(A, B) {
            return [
                [
                    A[0][0]*B[0][0] + A[0][1]*B[1][0] + A[0][2]*B[2][0],
                    A[0][0]*B[0][1] + A[0][1]*B[1][1] + A[0][2]*B[2][1],
                    A[0][0]*B[0][2] + A[0][1]*B[1][2] + A[0][2]*B[2][2]
                ],
                [
                    A[1][0]*B[0][0] + A[1][1]*B[1][0] + A[1][2]*B[2][0],
                    A[1][0]*B[0][1] + A[1][1]*B[1][1] + A[1][2]*B[2][1],
                    A[1][0]*B[0][2] + A[1][1]*B[1][2] + A[1][2]*B[2][2]
                ],
                [
                    A[2][0]*B[0][0] + A[2][1]*B[1][0] + A[2][2]*B[2][0],
                    A[2][0]*B[0][1] + A[2][1]*B[1][1] + A[2][2]*B[2][1],
                    A[2][0]*B[0][2] + A[2][1]*B[1][2] + A[2][2]*B[2][2]
                ]
            ];
        }

        // Helper Function to Read File
        function readFileAsText(file) {
             return new Promise((resolve, reject) => {
                 const reader = new FileReader();
                 reader.onload = (event) => {
                     // Determine file format
                     let format = 'pdb'; // Default to pdb instead of unknown
                     const fileName = file.name.toLowerCase();
                     if (fileName.endsWith('.pdb')) {
                         format = 'pdb';
                     } else if (fileName.endsWith('.cif') || fileName.endsWith('.mmcif')) {
                         format = 'mmcif';
                     } else if (fileName.endsWith('.pdbqt')) {
                         format = 'pdbqt';
                     } else if (fileName.endsWith('.gro')) {
                         format = 'gro';
                     } else if (fileName.endsWith('.xyz')) {
                         format = 'xyz';
                     } else if (fileName.endsWith('.mol')) {
                         format = 'mol';
                     } else if (fileName.endsWith('.mol2')) {
                         format = 'mol2';
                     } else if (fileName.endsWith('.sdf')) {
                         format = 'sdf';
                     }
                     resolve({ 
                         name: file.name, 
                         data: event.target.result,
                         format: format
                     });
                 };
                 reader.onerror = (error) => reject(error);
                 reader.readAsText(file);
             });
        }

        // Init function
        async function init() {
            // Wait for DOM to be ready
            if (document.readyState !== 'complete') {
                await new Promise(resolve => {
                    if (document.readyState === 'complete') {
                        resolve();
                    } else {
                        window.addEventListener('load', resolve, { once: true });
                    }
                });
            }
            
            // Wait for Molstar to be available
            let retries = 0;
            while (typeof molstar === 'undefined' && retries < 50) {
                await new Promise(resolve => setTimeout(resolve, 100));
                retries++;
            }
            
            if (typeof molstar === 'undefined') {
                console.error('Molstar failed to load after 5 seconds');
                alert('Failed to load Molstar library. Please check your internet connection.');
                return;
            }
            
            // Initialize Molstar viewer
            const viewerContainer = document.getElementById('viewer-container');
            if (!viewerContainer) {
                console.error('Viewer container not found');
                return;
            }
            
            try {
                viewer = await molstar.Viewer.create('viewer-container', {
                    layoutIsExpanded: false,
                    layoutShowControls: false,
                    layoutShowLeftPanel: false,
                    layoutShowSequence: false,
                    layoutShowLog: false,
                    viewportShowExpand: false,
                    viewportShowSelectionMode: false,
                    viewportShowAnimation: false
                });
                
                console.log('Molstar viewer initialized successfully');
                
                // Notify VSCode that webview is ready
                vscode.postMessage({
                    command: 'webviewReady'
                });
                
            } catch (error) {
                console.error('Failed to initialize Molstar viewer:', error);
                alert('Failed to initialize viewer: ' + error.message);
                return;
            }

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', handleKeyDown);
            document.getElementById('reset-view').addEventListener('click', resetView);
            
            // View mode is now fixed to cartoon mode only
            
            // Layout mode controls
            document.getElementById('single-view').addEventListener('click', () => setLayoutMode('single'));
            document.getElementById('grid-view').addEventListener('click', () => setLayoutMode('grid'));
            
            // Cartoon controls removed per requirements
            
            // Sphere controls removed - using cartoon mode only

            // Color controls - Dropdown
            const colorModeButton = document.getElementById('color-mode-button');
            const colorModeDropdown = document.querySelector('.color-mode-dropdown');
            const colorModeOptions = document.querySelectorAll('.color-mode-option');
            const paletteOptions = document.querySelectorAll('.palette-option');

            // Toggle dropdown
            colorModeButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpening = !colorModeDropdown.classList.contains('open');
                colorModeDropdown.classList.toggle('open');

                // Position dropdown using fixed positioning
                if (isOpening) {
                    const rect = colorModeButton.getBoundingClientRect();
                    const dropdown = document.getElementById('color-mode-options');
                    dropdown.style.top = `${rect.bottom + 4}px`;
                    dropdown.style.left = `${rect.left}px`;
                }
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!colorModeDropdown.contains(e.target)) {
                    colorModeDropdown.classList.remove('open');
                }
            });

            // Handle color mode selection
            colorModeOptions.forEach(option => {
                option.addEventListener('click', (e) => {
                    const mode = option.dataset.mode;
                    if (mode !== 'rainbow') {
                        e.stopPropagation();
                        changeColorMode(mode);
                        colorModeDropdown.classList.remove('open');
                    }
                    // Rainbow mode has sub-options, keep dropdown open
                });
            });

            // Handle rainbow palette selection
            paletteOptions.forEach(option => {
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const palette = option.dataset.palette;
                    currentRainbowPalette = palette;
                    changeColorMode('rainbow');
                    colorModeDropdown.classList.remove('open');
                });
            });

            // Illustrative style toggle
            document.getElementById('illustrative-style-toggle').addEventListener('change', async (e) => {
                illustrativeStyleEnabled = e.target.checked;
                await applyIllustrativeStyle(illustrativeStyleEnabled);
            });

            // Color palette
            document.querySelectorAll('.color-option').forEach(option => {
                option.addEventListener('click', () => {
                    const color = option.dataset.color;
                    selectCustomColor(color);
                });
            });
            
            // VSCode Integration Event Listeners
            document.getElementById('request-pdb-files').addEventListener('click', requestPDBFiles);
            document.getElementById('request-folder').addEventListener('click', requestFolder);
            
            // Animation controls
            document.getElementById('animation-slider').addEventListener('input', handleAnimationSlider);
            document.getElementById('play-pause').addEventListener('click', togglePlayPause);
            document.getElementById('play-forward').addEventListener('click', playForward);
            document.getElementById('play-backward').addEventListener('click', playBackward);
            document.getElementById('next-frame').addEventListener('click', nextFrame);
            document.getElementById('prev-frame').addEventListener('click', prevFrame);
            document.getElementById('animation-speed').addEventListener('input', updateAnimationSpeed);
            
            // Download controls
            document.getElementById('download-animation').addEventListener('click', toggleDownloadOptions);
            document.getElementById('download-mp4').addEventListener('click', () => downloadAnimation('mp4'));
            document.getElementById('download-gif').addEventListener('click', () => downloadAnimation('gif'));
            document.getElementById('download-all-files').addEventListener('click', downloadAllFiles);
            
            // Sequence alignment event listeners
            document.getElementById('seq-alignment-toggle').addEventListener('change', toggleSequenceAlignment);
            document.getElementById('fasta-mode').addEventListener('click', () => setInputMode('fasta'));
            document.getElementById('single-mode').addEventListener('click', () => setInputMode('single'));
            document.getElementById('upload-fasta-btn').addEventListener('click', () => document.getElementById('fasta-file-input').click());
            document.getElementById('fasta-file-input').addEventListener('change', handleFastaFileUpload);
            document.getElementById('parse-fasta-btn').addEventListener('click', parseFastaInput);
            document.getElementById('add-single-sequence-btn').addEventListener('click', addSingleSequence);
            document.getElementById('fold-all-btn').addEventListener('click', foldAllSequences);
            document.getElementById('clear-sequences-btn').addEventListener('click', clearAllSequences);
            document.getElementById('dual-session-radio').addEventListener('change', handleDisplayModeChange);
            document.getElementById('seq-only-radio').addEventListener('change', handleDisplayModeChange);
            document.getElementById('align-mode-radio').addEventListener('change', handleDisplayModeChange);
            document.getElementById('plddt-info-toggle').addEventListener('change', togglePLDDTInfo);
            
            // Structure alignment event listeners
            document.getElementById('reference-structure-select').addEventListener('change', updateAlignmentButtonState);
            document.getElementById('align-structures-btn').addEventListener('click', performStructureAlignment);
            document.getElementById('export-conservation-btn').addEventListener('click', exportConservationAnalysis);
            
            // Update reference structure dropdown when files are loaded
            updateReferenceStructureDropdown();

            // --- Collapse Button Listeners ---
            const toggleButton = document.getElementById('toggle-file-list');
            const fileHistoryEl = document.getElementById('file-history');
            const fileListPanel = document.getElementById('file-list-panel');
            
            toggleButton.addEventListener('click', () => {
                const isCollapsed = fileListPanel.classList.toggle('collapsed');
                toggleButton.textContent = isCollapsed ? '[+]' : '[−]';
                toggleButton.title = isCollapsed ? 'Expand File List' : 'Collapse File List';
                
                // Also handle the file history collapse state
                if (isCollapsed) {
                    fileHistoryEl.classList.add('collapsed');
                } else {
                    fileHistoryEl.classList.remove('collapsed');
                }
            });
            
            // Controls panel collapse listener
            const toggleControlsButton = document.getElementById('toggle-controls');
            const controlsPanel = document.getElementById('controls');
            
            toggleControlsButton.addEventListener('click', () => {
                const isCollapsed = controlsPanel.classList.toggle('collapsed');
                toggleControlsButton.textContent = isCollapsed ? '[+]' : '[−]';
                toggleControlsButton.title = isCollapsed ? 'Expand Controls' : 'Collapse Controls';
            });
            
            // Initialize UI state
            // View mode UI update removed - cartoon only
            updateColorModeUI();
            selectCustomColor(currentCustomColor);
            
            // Notify VSCode that webview is ready
            vscode.postMessage({
                command: 'webviewReady'
            });
        }

        // Animation loop (handled by Molstar internally)

        // Window resize handler
        function onWindowResize() {
            if (viewer) {
                viewer.handleResize();
            }
            document.getElementById('controls').style.maxHeight = `calc(100vh - 20px)`;
            document.getElementById('file-list-panel').style.maxHeight = `calc(100vh - 20px)`;
        }

        // Reset camera view
        function resetView() {
            if (viewer) {
                viewer.plugin.managers.camera.reset();
            }
        }

        // Handle Batch File Select (with sorting)
        async function handleBatchFileSelect(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;
            const loadingIndicator = document.getElementById('loading');
            loadingIndicator.textContent = `Loading ${files.length} file(s)...`;
            loadingIndicator.style.display = 'block';

            const readFilePromises = Array.from(files).map(file => readFileAsText(file));
            let firstNewFileName = null; // Keep track of the first file added in this batch

            try {
                const results = await Promise.all(readFilePromises);

                if (results.length > 0) {
                    firstNewFileName = results[0].name; // Get name before potential duplicates are added
                    results.forEach(result => {
                        // Add even if duplicate name exists, per previous request
                        loadedFiles.push({ 
                            name: result.name, 
                            data: result.data,
                            format: result.format,
                            source: 'local'
                        });
                    });

                    // --- Sort the list ---
                    loadedFiles.sort((a, b) => naturalSort(a.name, b.name));

                    // --- Find the new index of the first added file ---
                    currentFileIndex = loadedFiles.findIndex(f => f.name === firstNewFileName);
                    // If somehow not found (e.g., error during read?), default to 0 if list not empty
                    if (currentFileIndex === -1 && loadedFiles.length > 0) {
                        currentFileIndex = 0;
                    }

                    // Display the selected file
                    if (currentFileIndex !== -1) {
                        parseStructureFile(
                            loadedFiles[currentFileIndex].data, 
                            loadedFiles[currentFileIndex].format, 
                            false
                        ); // Don't maintain view
                    }

                    updateFileHistory();
                    document.getElementById('animation-controls').style.display = 'none';
                    stopAnimation();
                } else {
                     updateFileHistory(); // Update even if no files added
                }

            } catch (error) {
                console.error("Error reading one or more files:", error);
                alert("An error occurred while reading files. Check the console.");
                updateFileHistory(); // Update list even if errors occurred
            } finally {
                loadingIndicator.style.display = 'none';
                event.target.value = null;
            }
        }

        // Handle folder selection for diffusion sequence (with sorting)
        async function handleFolderSelect(event) {
             const files = event.target.files;
             if (!files || files.length === 0) return;
             const loadingIndicator = document.getElementById('loading');
             loadingIndicator.textContent = 'Loading diffusion sequence...';
             loadingIndicator.style.display = 'block';

             diffusionSteps = []; // Clear previous sequence
             stopAnimation();

             // Filter for structure files
             const structureFilesInput = Array.from(files).filter(file => {
                 const lowerName = file.name.toLowerCase();
                 return lowerName.endsWith('.pdb') || lowerName.endsWith('.cif') || lowerName.endsWith('.mmcif') || 
                        lowerName.endsWith('.pdbqt') || lowerName.endsWith('.gro') || lowerName.endsWith('.xyz') || 
                        lowerName.endsWith('.mol') || lowerName.endsWith('.mol2') || lowerName.endsWith('.sdf');
             });
             
             if (structureFilesInput.length === 0) {
                 loadingIndicator.style.display = 'none';
                 alert('No structure files found in the selected folder.');
                 return;
             }

             const readFilePromises = structureFilesInput.map(file => readFileAsText(file));
             let firstStepFileName = null; // Keep track of the intended first step file

             try {
                 const results = await Promise.all(readFilePromises);
                 let newFilesAddedToMainList = false;

                 results.forEach(result => {
                     const stepMatch = result.name.match(/(\d+)/);
                     const stepNum = stepMatch ? parseInt(stepMatch[1]) : diffusionSteps.length;
                     diffusionSteps.push({ 
                         name: result.name, 
                         step: stepNum, 
                         data: result.data,
                         format: result.format 
                     });

                     // Add to main list if not already present
                     if (!loadedFiles.some(f => f.name === result.name)) {
                         loadedFiles.push({ 
                             name: result.name, 
                             data: result.data,
                             format: result.format,
                             source: 'local'
                         });
                         newFilesAddedToMainList = true;
                     }
                 });

                 if (diffusionSteps.length > 0) {
                     // Sort diffusion steps by step number
                     diffusionSteps.sort((a, b) => a.step - b.step);
                     firstStepFileName = diffusionSteps[0].name; // Name of the file to be displayed first

                     // --- Sort the main loadedFiles list if new files were added ---
                     if (newFilesAddedToMainList) {
                         loadedFiles.sort((a, b) => naturalSort(a.name, b.name));
                     }

                     // --- Find the index of the first step file in the (potentially sorted) main list ---
                     currentFileIndex = loadedFiles.findIndex(f => f.name === firstStepFileName);
                     if (currentFileIndex === -1) { // Fallback if something went wrong
                          console.warn("Could not find first step file in loadedFiles list after sorting.");
                          currentFileIndex = 0; // Default to first in list
                     }

                     // Display the first step
                     currentStepIndex = 0; // Index within diffusionSteps array
                     displayDiffusionStep(currentStepIndex, false); // Don't maintain view for first frame

                     updateFileHistory();
                     initializeAnimationControls();
                 } else {
                     updateFileHistory();
                 }

             } catch (error) {
                 console.error("Error reading files for diffusion sequence:", error);
                 alert("An error occurred while reading sequence files. Check console.");
                 updateFileHistory();
             } finally {
                 loadingIndicator.style.display = 'none';
                 event.target.value = null;
             }
         }

        // Initialize animation controls
        function initializeAnimationControls() {
            if (diffusionSteps.length === 0) {
                 document.getElementById('animation-controls').style.display = 'none';
                 return;
            }
            const slider = document.getElementById('animation-slider');
            slider.min = 0;
            slider.max = diffusionSteps.length - 1;
            slider.value = currentStepIndex;
            document.getElementById('current-step').textContent = diffusionSteps[currentStepIndex]?.step ?? 'N/A';
            document.getElementById('total-steps').textContent = diffusionSteps[diffusionSteps.length - 1]?.step ?? 'N/A';
            document.getElementById('animation-controls').style.display = 'block';
            
            // Initialize button states
            playDirection = 1; // Default to forward
            updateDirectionButtons();
            stopAnimation();
        }

        // Display a specific diffusion step
        // **Important**: Needs to update `currentFileIndex` after identifying the file
        function displayDiffusionStep(index, maintainView = true) {
            if (index < 0 || index >= diffusionSteps.length) return;
            currentStepIndex = index;
            const stepData = diffusionSteps[index];
            document.getElementById('animation-slider').value = index;
            document.getElementById('current-step').textContent = stepData.step;

            // --- Update currentFileIndex based on the step being displayed ---
            const correspondingFileIndex = loadedFiles.findIndex(file => file.name === stepData.name);
            if (correspondingFileIndex !== -1) {
                currentFileIndex = correspondingFileIndex; // Keep main list selection synced
            } else {
                 console.warn(`Could not find file ${stepData.name} in loadedFiles.`);
                 // Optionally deselect in main list: currentFileIndex = -1;
            }

            // Handle dual session mode for diffusion steps too
            (async () => {
                if (currentSessionMode === 'dual' && sequenceAlignmentEnabled) {
                    // Find if current file has a corresponding sequence to maintain dual session
                    const matchingSequence = parsedSequences.find(seq => {
                        const match = findMatchingStructure(seq.header);
                        return match && match.name === stepData.name;
                    });
                    
                    if (matchingSequence && matchingSequence.status === 'completed') {
                        // Update dual session with new file and its predicted structure
                        await loadDualSessionStructures(matchingSequence, { name: stepData.name, data: stepData.data, format: stepData.format });
                    } else {
                        // No matching sequence, fall back to single mode
                        await initializeSingleSessionMode();
                        parseStructureFile(stepData.data, stepData.format, maintainView);
                    }
                } else {
                    // Normal single session mode
                    parseStructureFile(stepData.data, stepData.format, maintainView);
                }
            })();
            
            updateFileHistory(); // Update highlighting based on the NEW currentFileIndex
        }

        // Handle animation slider change
        function handleAnimationSlider(event) {
             const sliderValue = parseInt(event.target.value);
             // Display step will handle updating currentFileIndex and history
             displayDiffusionStep(sliderValue, true);
              if (isPlaying) {
                  togglePlayPause();
              }
        }

        // Helper to stop animation cleanly
        function stopAnimation() {
             isPlaying = false;
             const playBtn = document.getElementById('play-pause');
             playBtn.textContent = '▶';
             playBtn.classList.remove('playing');
             if (animationTimer) {
                 clearInterval(animationTimer);
                 animationTimer = null;
             }
        }

        // Toggle play/pause
        function togglePlayPause() {
            if (diffusionSteps.length === 0) return;
            isPlaying = !isPlaying;
            const playBtn = document.getElementById('play-pause');
            
            if (isPlaying) {
                playBtn.textContent = '⏸';
                playBtn.classList.add('playing');
                const frameTime = 1000 / (5 * animationSpeed);
                animationTimer = setInterval(() => {
                    const nextIndex = currentStepIndex + playDirection;
                    if (nextIndex < 0 || nextIndex >= diffusionSteps.length) {
                        stopAnimation();
                        return;
                    }
                    // displayDiffusionStep handles updating main index and history
                    displayDiffusionStep(nextIndex, true);
                }, Math.max(frameTime, 20));
            } else {
                stopAnimation();
            }
        }

        // Play forward/backward, next/prev frame
        function playForward() { 
            if (diffusionSteps.length > 0) { 
                playDirection = 1; 
                updateDirectionButtons();
                if (!isPlaying) togglePlayPause(); 
            } 
        }
        function playBackward() { 
            if (diffusionSteps.length > 0) { 
                playDirection = -1; 
                updateDirectionButtons();
                if (!isPlaying) togglePlayPause(); 
            } 
        }
        // **Important**: Needs displayDiffusionStep to update main index
        function nextFrame() { if (diffusionSteps.length > 0) { if (isPlaying) stopAnimation(); const nextIndex = currentStepIndex + 1; if (nextIndex < diffusionSteps.length) displayDiffusionStep(nextIndex, true); } }
        function prevFrame() { if (diffusionSteps.length > 0) { if (isPlaying) stopAnimation(); const prevIndex = currentStepIndex - 1; if (prevIndex >= 0) displayDiffusionStep(prevIndex, true); } }

        // Update animation speed
        function updateAnimationSpeed(event) {
            animationSpeed = parseFloat(event.target.value);
            document.getElementById('animation-speed-value').textContent = animationSpeed.toFixed(1);
            if (isPlaying && animationTimer) {
                stopAnimation();
                togglePlayPause();
            }
        }
        
        // Update direction button styling
        function updateDirectionButtons() {
            const forwardBtn = document.getElementById('play-forward');
            const backwardBtn = document.getElementById('play-backward');
            
            forwardBtn.classList.toggle('active', playDirection === 1);
            backwardBtn.classList.toggle('active', playDirection === -1);
        }
        

        // Function to determine file format from content
        function detectFileFormat(content) {
            // Check for mmCIF format - typically starts with "data_" or has "_atom_site." tags
            if (content.includes('data_') || content.includes('_atom_site.')) {
                return 'mmcif';
            } 
            // Otherwise assume PDB format
            return 'pdb';
        }

        // Main parsing function using Molstar
        async function parseStructureFile(fileData, format, maintainView = false) {
            // Wait for viewer to be initialized
            let retries = 0;
            while (!viewer && retries < 100) {
                await new Promise(resolve => setTimeout(resolve, 50));
                retries++;
            }
            
            if (!viewer) {
                console.error('Viewer not initialized after 5 seconds');
                vscode.postMessage({
                    command: 'showError',
                    message: 'Viewer not ready. Please wait a moment and try again.'
                });
                return;
            }
            
            try {
                // Store current file data for refreshing
                currentFileData = fileData;
                currentFileFormat = format;
                
                // Verify file data exists and is valid
                if (!fileData || typeof fileData !== 'string' || fileData.trim().length === 0) {
                    throw new Error('Invalid or empty file data');
                }
                
                // Clear existing structures
                const plugin = viewer.plugin;
                await plugin.clear();
                
                currentModels = [];
                
                // Verify or detect the format if not provided
                const detectedFormat = format || detectFileFormat(fileData);
                
                // Create blob with proper MIME type
                const getMimeType = (format) => {
                    switch (format) {
                        case 'mmcif': return 'chemical/x-mmcif';
                        case 'gro': return 'chemical/x-gromacs-gro';
                        case 'xyz': return 'chemical/x-xyz';
                        case 'mol': return 'chemical/x-mdl-molfile';
                        case 'mol2': return 'chemical/x-mol2';
                        case 'sdf': return 'chemical/x-mdl-sdfile';
                        default: return 'chemical/x-pdb';
                    }
                };
                const mimeType = getMimeType(detectedFormat);
                const blob = new Blob([fileData], { type: mimeType });
                const blobUrl = URL.createObjectURL(blob);
                
                try {
                    // Use the plugin's data loading mechanism directly
                    const data = await plugin.builders.data.download({
                        url: blobUrl,
                        isBinary: false
                    });
                    
                    // Parse trajectory 
                    const formatMapping = {
                        'mmcif': 'mmcif',
                        'pdb': 'pdb',
                        'pdbqt': 'pdbqt',
                        'gro': 'gro',
                        'xyz': 'xyz',
                        'mol': 'mol',
                        'mol2': 'mol2',
                        'sdf': 'sdf',
                        'unknown': 'pdb'
                    };
                    
                    const molstarFormat = formatMapping[detectedFormat] || 'pdb';
                    console.log(`Loading file with format: ${detectedFormat} -> Molstar format: ${molstarFormat}`);
                    const trajectory = await plugin.builders.structure.parseTrajectory(data, molstarFormat);
                    
                    // Apply default preset
                    await plugin.builders.structure.hierarchy.applyPreset(trajectory, 'default');
                    
                    // Store structure reference (for tracking)
                    currentModels = ['loaded'];
                    
                    // Set default color mode based on format
                    if (['xyz', 'sdf', 'mol', 'mol2'].includes(format)) {
                        currentColorMode = 'element';
                        updateColorModeUI();
                    }
                    
                    // Apply current color theme after loading structure
                    if (currentColorMode === 'rainbow') {
                        await applyRainbowColoring(viewer, currentRainbowPalette);
                    } else {
                        await updateColorTheme(getColorThemeName(), getColorThemeParams());
                    }
                    
                    // Count atoms (approximate - Molstar doesn't easily expose atom count)
                    document.getElementById('atom-count').textContent = 'Loaded';
                    
                    if (!maintainView) {
                        viewer.plugin.managers.camera.reset();
                    }
                    
                } finally {
                    // Clean up blob URL
                    URL.revokeObjectURL(blobUrl);
                }
                
            } catch (error) {
                console.error('Error parsing structure file:', error);
                document.getElementById('atom-count').textContent = 0;
                alert('Error loading structure: ' + error.message);
            }
        }

        // Store current file data for reloading
        let currentFileData = null;
        let currentFileFormat = null;
        
        // Helper functions for color theme management
        function getColorThemeName() {
            switch (currentColorMode) {
                case 'element': return 'element-symbol';
                case 'residue': return 'residue-name';
                case 'chain': return 'chain-id';
                case 'custom': return 'uniform';
                default: return 'uniform';
            }
        }

        function getColorThemeParams() {
            if (currentColorMode === 'custom') {
                // Convert hex color to Molstar Color format
                const hexValue = parseInt(currentCustomColor.replace('#', ''), 16);
                return { value: hexValue };
            }
            return {};
        }

        // Update color theme efficiently without reloading structure
        async function updateColorTheme(colorThemeName, colorParams = {}) {
            if (!viewer) return;
            
            try {
                const plugin = viewer.plugin;
                const structures = plugin.managers.structure.hierarchy.current.structures;
                
                for (const structure of structures) {
                    for (const component of structure.components) {
                        if (component.representations) {
                            for (const repr of component.representations) {
                                const update = plugin.build().to(repr.cell).update({
                                    ...repr.cell.transform.params,
                                    colorTheme: { name: colorThemeName, params: colorParams }
                                });
                                await update.commit();
                            }
                        }
                    }
                }
                
                console.log('Color theme updated to:', colorThemeName);
            } catch (error) {
                console.error('Error updating color theme:', error);
            }
        }
        
        // Update color theme selectively, skipping predicted structures
        async function updateColorThemeSelective(colorThemeName, colorParams = {}) {
            if (!viewer) return;
            
            try {
                const plugin = viewer.plugin;
                const structures = plugin.managers.structure.hierarchy.current.structures;
                
                for (const structure of structures) {
                    // Check if this structure is a predicted structure (should keep pLDDT coloring)
                    const structureId = structure.cell.transform.ref;
                    if (predictedStructureIds.has(structureId)) {
                        console.log('Skipping color update for predicted structure:', structureId);
                        continue; // Skip predicted structures
                    }
                    
                    for (const component of structure.components) {
                        if (component.representations) {
                            for (const repr of component.representations) {
                                const update = plugin.build().to(repr.cell).update({
                                    ...repr.cell.transform.params,
                                    colorTheme: { name: colorThemeName, params: colorParams }
                                });
                                await update.commit();
                            }
                        }
                    }
                }
                
                console.log('Selective color theme updated to:', colorThemeName, '(skipped predicted structures)');
            } catch (error) {
                console.error('Error updating selective color theme:', error);
            }
        }

        // Refresh visualization based on current settings
        async function refreshVisualization() {
            if (!viewer || currentModels.length === 0) return;

            console.log('Refreshing visualization - Color:', currentColorMode);

            // Handle rainbow mode separately
            if (currentColorMode === 'rainbow') {
                // Apply rainbow coloring to main viewer
                await applyRainbowColoring(viewer, currentRainbowPalette);

                // Also update all grid viewers if in grid mode
                if (currentLayoutMode === 'grid') {
                    await applyRainbowColoringToAllGridViewers();
                }

                // Apply to dual session left viewer if active
                if (currentSessionMode === 'dual' && leftViewer) {
                    await applyRainbowColoring(leftViewer, currentRainbowPalette);
                }
            } else {
                // Update color theme efficiently (no view mode changes needed - cartoon only)
                // But skip predicted structures that should maintain pLDDT coloring
                await updateColorThemeSelective(getColorThemeName(), getColorThemeParams());

                // Also update all grid viewers if in grid mode
                if (currentLayoutMode === 'grid') {
                    await updateAllGridViewersColor();
                }
            }
        }
        
        // Update colors for all active grid viewers
        async function updateAllGridViewersColor() {
            for (let i = 0; i < gridViewers.length; i++) {
                if (gridViewers[i] && activeGridViewers.has(i)) {
                    try {
                        await applyColorThemeToViewer(gridViewers[i]);
                    } catch (error) {
                        console.error(`Error updating grid viewer ${i} color:`, error);
                    }
                }
            }
        }

        // Cartoon control update functions removed per requirements
        
        // View mode management removed - cartoon only mode
        
        // Layout mode management
        async function setLayoutMode(mode) {
            currentLayoutMode = mode;
            updateLayoutModeUI();
            
            if (mode === 'grid') {
                // Auto-close all active grid viewers when switching to grid view
                await closeAllActiveViewers();
                await createGridView();
            } else {
                await exitGridView();
            }
        }
        
        function updateLayoutModeUI() {
            const singleBtn = document.getElementById('single-view');
            const gridBtn = document.getElementById('grid-view');
            const container = document.getElementById('container');

            if (currentLayoutMode === 'single') {
                singleBtn.classList.add('active');
                gridBtn.classList.remove('active');
                container.className = 'single-view';
            } else {
                singleBtn.classList.remove('active');
                gridBtn.classList.add('active');
                container.className = 'grid-view-mode';
            }
        }

        // Rainbow coloring implementation
        async function applyRainbowColoring(targetViewer, paletteName = 'rainbow') {
            if (!targetViewer || !targetViewer.plugin) {
                console.warn('Target viewer is null, skipping rainbow coloring');
                return;
            }

            try {
                const plugin = targetViewer.plugin;
                const structures = plugin.managers.structure.hierarchy.current.structures;

                if (!structures || structures.length === 0) {
                    console.warn('No structures found for rainbow coloring');
                    return;
                }

                console.log(`Applying rainbow coloring with palette: ${paletteName}`);

                // Create unique theme name for this instance
                const themeName = `rainbow-sequence-${paletteName}-${Math.random().toString(36).substring(7)}`;

                // Define the rainbow color theme provider
                const RainbowSequenceColorThemeProvider = {
                    name: themeName,
                    label: `Rainbow (${paletteName})`,
                    category: "Custom",
                    factory: (ctx, props) => {
                        // Get the structure from context
                        const structure = ctx.structure;
                        if (!structure || !structure.models || structure.models.length === 0) {
                            console.warn('No structure models found');
                            return {
                                factory: RainbowSequenceColorThemeProvider.factory,
                                granularity: 'group',
                                color: () => 0x808080,
                                props: props
                            };
                        }

                        // Find min and max sequence IDs by iterating through residues
                        let minSeqId = Infinity;
                        let maxSeqId = -Infinity;

                        // Iterate through all units and residues
                        for (const unit of structure.units) {
                            const { model } = unit;
                            const { residues } = model.atomicHierarchy;

                            // Iterate through residues in this unit
                            for (let i = 0; i < residues._rowCount; i++) {
                                const seqId = residues.label_seq_id.value(i);
                                if (seqId > 0) {
                                    minSeqId = Math.min(minSeqId, seqId);
                                    maxSeqId = Math.max(maxSeqId, seqId);
                                }
                            }
                        }

                        // Handle case where no sequence IDs were found
                        if (minSeqId === Infinity || maxSeqId === -Infinity) {
                            console.warn('Could not determine sequence ID range');
                            minSeqId = 1;
                            maxSeqId = 100;
                        }

                        const totalResidues = maxSeqId - minSeqId + 1;
                        console.log(`Sequence range: ${minSeqId} to ${maxSeqId} (${totalResidues} residues)`);

                        // Generate gradient for the number of residues
                        const paletteColors = RAINBOW_PALETTES[paletteName] || RAINBOW_PALETTES['rainbow'];
                        const gradient = generateGradient(paletteColors, totalResidues);

                        return {
                            factory: RainbowSequenceColorThemeProvider.factory,
                            granularity: 'group',
                            color: (location) => {
                                // Get sequence ID from location
                                try {
                                    const unit = location.unit;
                                    const element = location.element;

                                    // Get residue from element
                                    const residueIndex = unit.model.atomicHierarchy.residueAtomSegments.index[element];
                                    const seqId = unit.model.atomicHierarchy.residues.label_seq_id.value(residueIndex);

                                    // Map sequence ID to color index
                                    const colorIndex = Math.max(0, Math.min(totalResidues - 1, seqId - minSeqId));
                                    const hexColor = gradient[colorIndex];

                                    return hexToMolstarColor(hexColor);
                                } catch (error) {
                                    // Fallback to gray if error
                                    return 0x808080;
                                }
                            },
                            props: props,
                            description: `Rainbow coloring by sequence position (${paletteName})`
                        };
                    },
                    getParams: () => ({}),
                    defaultValues: {},
                    isApplicable: (ctx) => !!ctx.structure
                };

                // Register the color theme
                plugin.representation.structure.themes.colorThemeRegistry.add(RainbowSequenceColorThemeProvider);
                console.log(`Registered rainbow theme: ${themeName}`);

                // Apply the theme to all structures
                for (const structure of structures) {
                    // Skip predicted structures (they should keep pLDDT coloring)
                    const structureId = structure.cell.transform.ref;
                    if (predictedStructureIds.has(structureId)) {
                        console.log('Skipping rainbow coloring for predicted structure:', structureId);
                        continue;
                    }

                    if (structure.components && structure.components.length > 0) {
                        await plugin.managers.structure.component.updateRepresentationsTheme(
                            structure.components,
                            { color: themeName }
                        );
                    }
                }

                console.log('Successfully applied rainbow coloring');

            } catch (error) {
                console.error('Error applying rainbow coloring:', error);
            }
        }

        // Apply rainbow coloring to all active grid viewers
        async function applyRainbowColoringToAllGridViewers() {
            for (let i = 0; i < gridViewers.length; i++) {
                if (gridViewers[i] && activeGridViewers.has(i)) {
                    try {
                        await applyRainbowColoring(gridViewers[i], currentRainbowPalette);
                    } catch (error) {
                        console.error(`Error applying rainbow coloring to grid viewer ${i}:`, error);
                    }
                }
            }
        }

        // Illustrative style management
        async function applyIllustrativeStyle(enabled) {
            if (!viewer || !viewer.plugin) return;

            try {
                const plugin = viewer.plugin;

                // Set ignoreLight option for all structures
                await plugin.managers.structure.component.setOptions({
                    ...plugin.managers.structure.component.state.options,
                    ignoreLight: enabled
                });

                // Apply canvas3d postprocessing effects
                if (plugin.canvas3d) {
                    if (enabled) {
                        // Apply illustrative style with outline and occlusion
                        const pp = plugin.canvas3d.props.postprocessing;
                        plugin.canvas3d.setProps({
                            postprocessing: {
                                outline: {
                                    name: 'on',
                                    params: pp.outline.name === 'on' ? pp.outline.params : {
                                        scale: 1,
                                        threshold: 0.33,
                                        includeTransparent: true
                                    }
                                },
                                occlusion: {
                                    name: 'on',
                                    params: pp.occlusion.name === 'on' ? pp.occlusion.params : {
                                        multiScale: { name: 'off', params: {} },
                                        radius: 5,
                                        bias: 0.8,
                                        blurKernelSize: 15,
                                        samples: 32,
                                        resolutionScale: 1
                                    }
                                },
                                shadow: { name: 'off', params: {} }
                            }
                        });
                    } else {
                        // Reset to default style
                        plugin.canvas3d.setProps({
                            postprocessing: {
                                outline: { name: 'off', params: {} },
                                occlusion: { name: 'off', params: {} },
                                shadow: { name: 'off', params: {} }
                            }
                        });
                    }
                }

                // Also apply to dual session viewers if active
                if (currentSessionMode === 'dual') {
                    if (leftViewer) await applyIllustrativeStyleToViewer(leftViewer, enabled);
                    if (rightViewer) await applyIllustrativeStyleToViewer(rightViewer, enabled);
                }

                // Apply to all grid viewers
                if (currentLayoutMode === 'grid') {
                    for (let i = 0; i < gridViewers.length; i++) {
                        if (gridViewers[i] && activeGridViewers.has(i)) {
                            await applyIllustrativeStyleToViewer(gridViewers[i], enabled);
                        }
                    }
                }

                console.log(`Illustrative style ${enabled ? 'enabled' : 'disabled'}`);
            } catch (error) {
                console.error('Error applying illustrative style:', error);
            }
        }

        async function applyIllustrativeStyleToViewer(targetViewer, enabled) {
            if (!targetViewer || !targetViewer.plugin) return;

            try {
                const plugin = targetViewer.plugin;

                // Set ignoreLight option for all structures
                await plugin.managers.structure.component.setOptions({
                    ...plugin.managers.structure.component.state.options,
                    ignoreLight: enabled
                });

                // Apply canvas3d postprocessing effects
                if (plugin.canvas3d) {
                    if (enabled) {
                        // Apply illustrative style with outline and occlusion
                        const pp = plugin.canvas3d.props.postprocessing;
                        plugin.canvas3d.setProps({
                            postprocessing: {
                                outline: {
                                    name: 'on',
                                    params: pp.outline.name === 'on' ? pp.outline.params : {
                                        scale: 1,
                                        threshold: 0.33,
                                        includeTransparent: true
                                    }
                                },
                                occlusion: {
                                    name: 'on',
                                    params: pp.occlusion.name === 'on' ? pp.occlusion.params : {
                                        multiScale: { name: 'off', params: {} },
                                        radius: 5,
                                        bias: 0.8,
                                        blurKernelSize: 15,
                                        samples: 32,
                                        resolutionScale: 1
                                    }
                                },
                                shadow: { name: 'off', params: {} }
                            }
                        });
                    } else {
                        // Reset to default style
                        plugin.canvas3d.setProps({
                            postprocessing: {
                                outline: { name: 'off', params: {} },
                                occlusion: { name: 'off', params: {} },
                                shadow: { name: 'off', params: {} }
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error applying illustrative style to viewer:', error);
            }
        }

        // Color mode management
        async function changeColorMode(mode) {
            currentColorMode = mode;
            updateColorModeUI();
            await refreshVisualization();
        }
        
        function updateColorModeUI() {
            // Update dropdown label
            const colorModeLabel = document.getElementById('color-mode-label');
            const modeNames = {
                'custom': 'Custom',
                'element': 'Element',
                'residue': 'Residue',
                'chain': 'Chain',
                'rainbow': `Rainbow (${currentRainbowPalette})`
            };
            colorModeLabel.textContent = modeNames[currentColorMode] || 'Custom';

            // Update active state in dropdown options
            document.querySelectorAll('.color-mode-option').forEach(option => {
                option.classList.remove('active');
                if (option.dataset.mode === currentColorMode) {
                    option.classList.add('active');
                }
            });

            // Update active palette option - clear all first, then set if in rainbow mode
            document.querySelectorAll('.palette-option').forEach(option => {
                option.classList.remove('active');
            });

            if (currentColorMode === 'rainbow') {
                document.querySelectorAll('.palette-option').forEach(option => {
                    if (option.dataset.palette === currentRainbowPalette) {
                        option.classList.add('active');
                    }
                });
            }

            // Show/hide custom color palette
            const customColors = document.getElementById('custom-colors');
            customColors.style.display = currentColorMode === 'custom' ? 'block' : 'none';
        }
        
        async function selectCustomColor(color) {
            currentCustomColor = color;
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('active');
            });
            document.querySelector(`[data-color="${color}"]`).classList.add('active');
            
            if (currentColorMode === 'custom') {
                await refreshVisualization();
            }
        }
        
        // Create offscreen viewer for generating preview images
        async function createOffscreenViewer() {
            // Create offscreen container
            const offscreenDiv = document.createElement('div');
            offscreenDiv.style.position = 'absolute';
            offscreenDiv.style.top = '-9999px';
            offscreenDiv.style.left = '-9999px';
            offscreenDiv.style.width = '400px';
            offscreenDiv.style.height = '400px';
            document.body.appendChild(offscreenDiv);
            
            try {
                const offscreenViewer = await molstar.Viewer.create(offscreenDiv, {
                    layoutIsExpanded: false,
                    layoutShowControls: false,
                    layoutShowLeftPanel: false,
                    layoutShowSequence: false,
                    layoutShowLog: false,
                    viewportShowExpand: false,
                    viewportShowSelectionMode: false,
                    viewportShowAnimation: false
                });
                
                return { viewer: offscreenViewer, container: offscreenDiv };
            } catch (error) {
                document.body.removeChild(offscreenDiv);
                throw error;
            }
        }
        
        // LRU Management Functions
        function addToViewerOrder(index) {
            // Remove if already exists
            const existingIndex = gridViewerOrder.indexOf(index);
            if (existingIndex !== -1) {
                gridViewerOrder.splice(existingIndex, 1);
            }
            // Add to end (most recent)
            gridViewerOrder.push(index);
        }
        
        function removeFromViewerOrder(index) {
            const existingIndex = gridViewerOrder.indexOf(index);
            if (existingIndex !== -1) {
                gridViewerOrder.splice(existingIndex, 1);
            }
        }
        
        async function closeOldestViewer() {
            if (gridViewerOrder.length === 0) return null;
            
            const oldestIndex = gridViewerOrder[0]; // First in array is oldest
            console.log(`Closing oldest viewer: ${oldestIndex}`);
            
            try {
                // Dispose the viewer
                if (gridViewers[oldestIndex] && gridViewers[oldestIndex].plugin) {
                    await gridViewers[oldestIndex].plugin.clear();
                    gridViewers[oldestIndex].plugin.dispose();
                }
                gridViewers[oldestIndex] = null;
                
                // Remove from active set and order
                activeGridViewers.delete(oldestIndex);
                removeFromViewerOrder(oldestIndex);
                
                // Revert to preview image
                const gridItem = document.querySelector(`[data-file-index="${oldestIndex}"]`);
                if (gridItem) {
                    const viewerContainer = gridItem.querySelector('.grid-item-viewer');
                    const expandButton = gridItem.querySelector('.grid-expand-button');
                    
                    // Remove expand button
                    if (expandButton) {
                        expandButton.remove();
                    }
                    
                    // Remove active class
                    gridItem.classList.remove('active');
                    
                    // Restore preview image
                    if (gridPreviewImages[oldestIndex]) {
                        updateGridItemWithPreview(oldestIndex, gridPreviewImages[oldestIndex]);
                    } else {
                        viewerContainer.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
                                Click to activate 3D viewer
                            </div>
                        `;
                    }
                }
                
                return oldestIndex;
                
            } catch (error) {
                console.error(`Error closing oldest viewer ${oldestIndex}:`, error);
                return null;
            }
        }
        
        // Close all active grid viewers and revert to preview images
        async function closeAllActiveViewers() {
            console.log(`Closing all ${activeGridViewers.size} active viewers...`);
            
            // Create a copy of the set to iterate over since we'll be modifying it
            const activeViewersCopy = new Set(activeGridViewers);
            
            for (const viewerIndex of activeViewersCopy) {
                try {
                    // Dispose the viewer
                    if (gridViewers[viewerIndex] && gridViewers[viewerIndex].plugin) {
                        await gridViewers[viewerIndex].plugin.clear();
                        gridViewers[viewerIndex].plugin.dispose();
                    }
                    gridViewers[viewerIndex] = null;
                    
                    // Remove from active set and order
                    activeGridViewers.delete(viewerIndex);
                    removeFromViewerOrder(viewerIndex);
                    
                    console.log(`Closed viewer ${viewerIndex}`);
                    
                } catch (error) {
                    console.error(`Error closing viewer ${viewerIndex}:`, error);
                }
            }
            
            // Clear the order array completely
            gridViewerOrder = [];
            
            console.log(`All viewers closed. Active count: ${activeGridViewers.size}`);
        }
        
        // Generate preview image for a file
        async function generatePreviewImage(file, index) {
            const { viewer: offscreenViewer, container: offscreenDiv } = await createOffscreenViewer();

            try {
                // Load structure
                await loadStructureIntoGridViewer(offscreenViewer, file);

                // Apply current illustrative style if enabled
                if (illustrativeStyleEnabled) {
                    await applyIllustrativeStyleToViewer(offscreenViewer, true);
                }

                // Wait for rendering
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Get canvas and convert to image
                const canvas = offscreenDiv.querySelector('canvas');
                if (canvas) {
                    const imageUrl = canvas.toDataURL('image/png');
                    gridPreviewImages[index] = imageUrl;
                    
                    // Update the grid item with the preview image if it's currently visible
                    updateGridItemWithPreview(index, imageUrl);
                    
                    // Update the grid item class if it's visible
                    const gridItem = document.querySelector(`[data-file-index="${index}"]`);
                    if (gridItem) {
                        gridItem.classList.remove('loading');
                    }
                } else {
                    gridPreviewImages[index] = null;
                }
                
            } catch (error) {
                console.error(`Error generating preview for file ${index}:`, error);
                gridPreviewImages[index] = null;
                
                // Update the grid item to show error state if it's currently visible
                updateGridItemWithPreview(index, null);
                const gridItem = document.querySelector(`[data-file-index="${index}"]`);
                if (gridItem) {
                    gridItem.classList.remove('loading');
                }
            } finally {
                // Clean up offscreen viewer
                try {
                    await offscreenViewer.plugin.clear();
                    offscreenViewer.plugin.dispose();
                } catch (error) {
                    console.error('Error disposing offscreen viewer:', error);
                }
                document.body.removeChild(offscreenDiv);
            }
        }
        
        // Update grid item with preview image
        function updateGridItemWithPreview(index, imageUrl) {
            const gridItem = document.querySelector(`[data-file-index="${index}"]`);
            if (!gridItem) {
                // Item might not be visible in current page, just update the data
                return;
            }
            
            gridItem.classList.remove('loading');
            
            // Find or create viewer container
            let viewerContainer = gridItem.querySelector('.grid-item-viewer');
            if (!viewerContainer) {
                viewerContainer = document.createElement('div');
                viewerContainer.className = 'grid-item-viewer';
                gridItem.appendChild(viewerContainer);
            }
            
            if (imageUrl) {
                // Add preview image
                viewerContainer.innerHTML = `
                    <img src="${imageUrl}" alt="Structure preview" class="grid-preview-image" />
                    <div class="grid-activation-overlay">Click to activate 3D viewer</div>
                `;
            } else {
                // Show error state
                viewerContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
                        Preview failed - Click to load
                    </div>
                `;
            }
        }
        
        // Grid view functions
        async function createGridView() {
            const gridContent = document.getElementById('grid-content');
            gridContent.innerHTML = '';
            
            // Preserve existing arrays if they exist, otherwise initialize
            if (gridViewers.length === 0) {
                gridViewers = [];
                activeGridViewers.clear();
            }
            if (gridPreviewImages.length === 0) {
                gridPreviewImages = [];
            }
            
            if (loadedFiles.length === 0) {
                gridContent.innerHTML = '<div style="text-align: center; padding: 50px; color: #666;">No structures loaded. Load some files to see them in grid view.</div>';
                return;
            }
            
            // Extend arrays if we have new files
            while (gridViewers.length < loadedFiles.length) {
                gridViewers.push(null);
            }
            while (gridPreviewImages.length < loadedFiles.length) {
                gridPreviewImages.push(null);
            }
            
            // Create grid items
            for (let i = 0; i < loadedFiles.length; i++) {
                const file = loadedFiles[i];
                const gridItem = document.createElement('div');
                gridItem.className = activeGridViewers.has(i) ? 'grid-item active' : 
                                   gridPreviewImages[i] ? 'grid-item' : 'grid-item loading';
                gridItem.dataset.fileIndex = i;
                
                // Add header with file name
                const header = document.createElement('div');
                header.className = 'grid-item-header';
                header.innerHTML = `
                    <span>${file.name}</span>
                    <span class="format-badge ${file.format}" style="float: right;">${file.format.toUpperCase()}</span>
                `;
                gridItem.appendChild(header);
                
                // Add viewer container
                const viewerContainer = document.createElement('div');
                viewerContainer.className = 'grid-item-viewer';
                gridItem.appendChild(viewerContainer);
                
                // Add click handler for activation
                gridItem.addEventListener('click', (e) => handleGridItemClick(i, e));
                
                gridContent.appendChild(gridItem);
                
                // If already activated, recreate the 3D viewer
                if (activeGridViewers.has(i)) {
                    const viewerId = `grid-viewer-${i}`;
                    viewerContainer.innerHTML = `<div id="${viewerId}" style="width: 100%; height: 100%;"></div>`;
                    
                    // Add expand button
                    const expandButton = document.createElement('div');
                    expandButton.className = 'grid-expand-button';
                    expandButton.innerHTML = '⛶';
                    expandButton.title = 'Expand to single view';
                    expandButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        expandToSingleView(i);
                    });
                    gridItem.appendChild(expandButton);
                    
                    // Ensure this viewer is in the order tracking
                    if (!gridViewerOrder.includes(i)) {
                        addToViewerOrder(i);
                    }
                    
                    // Recreate the viewer asynchronously
                    setTimeout(async () => {
                        try {
                            const gridViewer = await molstar.Viewer.create(viewerId, {
                                layoutIsExpanded: false,
                                layoutShowControls: false,
                                layoutShowLeftPanel: false,
                                layoutShowSequence: false,
                                layoutShowLog: false,
                                viewportShowExpand: false,
                                viewportShowSelectionMode: false,
                                viewportShowAnimation: false
                            });
                            
                            gridViewers[i] = gridViewer;
                            await loadStructureIntoGridViewer(gridViewer, file);
                        } catch (error) {
                            console.error(`Error recreating grid viewer ${i}:`, error);
                        }
                    }, 100);
                    
                } else if (gridPreviewImages[i]) {
                    // Show cached preview image
                    updateGridItemWithPreview(i, gridPreviewImages[i]);
                } else {
                    // Generate preview image if not cached
                    setTimeout(() => {
                        generatePreviewImage(file, i).catch(error => {
                            console.error(`Failed to generate preview for ${file.name}:`, error);
                            gridPreviewImages[i] = null;
                            updateGridItemWithPreview(i, null);
                        });
                    }, i * 500);
                }
            }
            
            // Highlight current file
            updateGridSelection();
        }
        
        async function loadStructureIntoGridViewer(gridViewer, file) {
            if (!gridViewer) {
                console.warn('Grid viewer is null, skipping structure loading');
                return;
            }
            
            try {
                // Clear any existing structures first
                await gridViewer.plugin.clear();
                
                // Verify file data exists and is valid
                if (!file.data || typeof file.data !== 'string' || file.data.trim().length === 0) {
                    throw new Error('Invalid or empty file data');
                }
                
                // Create blob with proper MIME type
                const getMimeType = (format) => {
                    switch (format) {
                        case 'mmcif': return 'chemical/x-mmcif';
                        case 'gro': return 'chemical/x-gromacs-gro';
                        case 'xyz': return 'chemical/x-xyz';
                        case 'mol': return 'chemical/x-mdl-molfile';
                        case 'mol2': return 'chemical/x-mol2';
                        case 'sdf': return 'chemical/x-mdl-sdfile';
                        default: return 'chemical/x-pdb';
                    }
                };
                const mimeType = getMimeType(file.format);
                const blob = new Blob([file.data], { type: mimeType });
                const blobUrl = URL.createObjectURL(blob);
                
                try {
                    // Use the plugin's data loading mechanism directly
                    const plugin = gridViewer.plugin;
                    
                    // Load data
                    const data = await plugin.builders.data.download({
                        url: blobUrl,
                        isBinary: false
                    });
                    
                    // Parse trajectory 
                    const formatMapping = {
                        'mmcif': 'mmcif',
                        'pdb': 'pdb',
                        'pdbqt': 'pdbqt',
                        'gro': 'gro',
                        'xyz': 'xyz',
                        'mol': 'mol',
                        'mol2': 'mol2',
                        'sdf': 'sdf',
                        'unknown': 'pdb'
                    };
                    
                    const molstarFormat = formatMapping[file.format] || 'pdb';
                    console.log(`Loading grid file: ${file.name} with format: ${file.format} -> Molstar format: ${molstarFormat}`);
                    const trajectory = await plugin.builders.structure.parseTrajectory(data, molstarFormat);
                    
                    // Apply default preset
                    await plugin.builders.structure.hierarchy.applyPreset(trajectory, 'default');
                    
                    // Set default color mode based on format for grid viewers
                    if (['xyz', 'sdf', 'mol', 'mol2'].includes(file.format)) {
                        // For grid viewers, we need to apply element coloring directly
                        await applyElementColoringToViewer(gridViewer);
                    } else {
                        // Apply current color theme after structure is loaded
                        await applyColorThemeToViewer(gridViewer);
                    }
                    
                } finally {
                    // Clean up blob URL
                    URL.revokeObjectURL(blobUrl);
                }
                
            } catch (error) {
                console.error('Error loading structure into grid viewer:', error);
                throw error; // Re-throw to handle in calling function
            }
        }
        
        async function applyColorThemeToViewer(targetViewer) {
            if (!targetViewer) {
                console.warn('Target viewer is null, skipping color theme application');
                return;
            }

            try {
                // Handle rainbow mode separately
                if (currentColorMode === 'rainbow') {
                    await applyRainbowColoring(targetViewer, currentRainbowPalette);
                    return;
                }

                const plugin = targetViewer.plugin;
                const structures = plugin.managers.structure.hierarchy.current.structures;

                for (const structure of structures) {
                    for (const component of structure.components) {
                        if (component.representations) {
                            for (const repr of component.representations) {
                                const update = plugin.build().to(repr.cell).update({
                                    ...repr.cell.transform.params,
                                    colorTheme: { name: getColorThemeName(), params: getColorThemeParams() }
                                });
                                await update.commit();
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error applying color theme to viewer:', error);
            }
        }
        
        async function applyElementColoringToViewer(targetViewer) {
            if (!targetViewer) {
                console.warn('Target viewer is null, skipping element coloring');
                return;
            }
            
            try {
                const plugin = targetViewer.plugin;
                const structures = plugin.managers.structure.hierarchy.current.structures;
                
                for (const structure of structures) {
                    for (const component of structure.components) {
                        if (component.representations) {
                            for (const repr of component.representations) {
                                const update = plugin.build().to(repr.cell).update({
                                    ...repr.cell.transform.params,
                                    colorTheme: { name: 'element-symbol', params: {} }
                                });
                                await update.commit();
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error applying element coloring to viewer:', error);
            }
        }
        
        async function handleGridItemClick(fileIndex, event) {
            // Check if target is the expand button (don't handle grid item click)
            if (event.target.classList.contains('grid-expand-button')) {
                return;
            }
            
            // If already activated, update LRU order and do nothing else
            if (activeGridViewers.has(fileIndex)) {
                addToViewerOrder(fileIndex); // Move to most recent
                return;
            }
            
            // First click - activate 3D viewer
            try {
                const gridItem = document.querySelector(`[data-file-index="${fileIndex}"]`);
                if (!gridItem) return;
                
                const viewerContainer = gridItem.querySelector('.grid-item-viewer');
                if (!viewerContainer) return;
                
                // Show loading state
                viewerContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
                        <div style="text-align: center;">
                            <div style="margin-bottom: 10px;">Loading 3D viewer...</div>
                            <div style="width: 20px; height: 20px; border: 2px solid #ddd; border-top: 2px solid #666; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                        </div>
                    </div>
                `;
                
                // Check WebGL context limit and auto-close oldest if needed
                if (activeGridViewers.size >= 16) {
                    console.log(`WebGL limit reached (${activeGridViewers.size}/16), closing oldest viewer...`);
                    const closedIndex = await closeOldestViewer();
                    if (closedIndex !== null) {
                        console.log(`Successfully closed viewer ${closedIndex}, proceeding with new activation`);
                    } else {
                        console.error('Failed to close oldest viewer');
                        viewerContainer.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; text-align: center; padding: 20px;">
                                WebGL context limit reached and unable to free space. Please try again.
                            </div>
                        `;
                        return;
                    }
                }
                
                // Create unique ID for this viewer
                const viewerId = `grid-viewer-${fileIndex}`;
                viewerContainer.innerHTML = `<div id="${viewerId}" style="width: 100%; height: 100%;"></div>`;
                
                // Create the Molstar viewer
                const gridViewer = await molstar.Viewer.create(viewerId, {
                    layoutIsExpanded: false,
                    layoutShowControls: false,
                    layoutShowLeftPanel: false,
                    layoutShowSequence: false,
                    layoutShowLog: false,
                    viewportShowExpand: false,
                    viewportShowSelectionMode: false,
                    viewportShowAnimation: false
                });
                
                // Store the viewer and add to tracking
                gridViewers[fileIndex] = gridViewer;
                activeGridViewers.add(fileIndex);
                addToViewerOrder(fileIndex); // Add as most recent
                
                // Load structure into the viewer
                await loadStructureIntoGridViewer(gridViewer, loadedFiles[fileIndex]);

                // Apply current illustrative style to the newly created viewer
                if (illustrativeStyleEnabled) {
                    await applyIllustrativeStyleToViewer(gridViewer, true);
                }

                // Add the expand button
                const expandButton = document.createElement('div');
                expandButton.className = 'grid-expand-button';
                expandButton.innerHTML = '⛶';
                expandButton.title = 'Expand to single view';
                expandButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    expandToSingleView(fileIndex);
                });
                gridItem.appendChild(expandButton);
                
                // Mark as active
                gridItem.classList.add('active');
                
                console.log(`Activated viewer ${fileIndex}. Active viewers: ${activeGridViewers.size}/16`);
                
            } catch (error) {
                console.error(`Error activating grid viewer ${fileIndex}:`, error);
                
                // Remove from active viewers if it was added but failed
                activeGridViewers.delete(fileIndex);
                removeFromViewerOrder(fileIndex);
                if (gridViewers[fileIndex]) {
                    try {
                        gridViewers[fileIndex].plugin.dispose();
                    } catch (disposeError) {
                        console.error('Error disposing failed viewer:', disposeError);
                    }
                    gridViewers[fileIndex] = null;
                }
                
                // Show error state
                const gridItem = document.querySelector(`[data-file-index="${fileIndex}"]`);
                if (gridItem) {
                    const viewerContainer = gridItem.querySelector('.grid-item-viewer');
                    if (viewerContainer) {
                        viewerContainer.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
                                Failed to load 3D viewer - Click to retry
                            </div>
                        `;
                    }
                }
            }
        }
        
        // Function to expand a grid item to single view
        function expandToSingleView(fileIndex) {
            currentFileIndex = fileIndex;
            expandedGridItem = fileIndex;
            setLayoutMode('single');
        }
        
        function updateGridSelection() {
            const gridItems = document.querySelectorAll('.grid-item');
            gridItems.forEach((item, index) => {
                if (index === currentFileIndex) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }
        
        async function exitGridView() {
            console.log('Exiting grid view, currentFileIndex:', currentFileIndex);
            
            // FIRST: Close some grid viewers to make room for main viewer
            console.log(`Active grid viewers before single view: ${activeGridViewers.size}`);
            if (activeGridViewers.size > 12) {
                // Close oldest viewers to make room for main viewer
                const viewersToClose = activeGridViewers.size - 12;
                console.log(`Closing ${viewersToClose} grid viewers to make room for main viewer`);
                
                for (let i = 0; i < viewersToClose; i++) {
                    await closeOldestViewer();
                }
            }
            
            // Clear grid content visually
            const gridContent = document.getElementById('grid-content');
            gridContent.innerHTML = '';
            
            // Ensure main viewer container is visible and ready
            const viewerContainer = document.getElementById('viewer-container');
            if (viewerContainer) {
                viewerContainer.style.display = 'block';
                viewerContainer.style.visibility = 'visible';
                viewerContainer.style.opacity = '1';
                
                // Force a reflow
                viewerContainer.offsetHeight;
                
                console.log('Viewer container made visible');
            }
            
            // ALWAYS reinitialize main viewer to ensure fresh WebGL context
            try {
                // Dispose existing viewer if it exists
                if (viewer && viewer.plugin) {
                    console.log('Disposing existing main viewer');
                    await viewer.plugin.clear();
                    viewer.plugin.dispose();
                }
                
                // Clear any existing content in viewer container
                if (viewerContainer) {
                    viewerContainer.innerHTML = '';
                }
                
                console.log('Creating fresh main viewer');
                viewer = await molstar.Viewer.create('viewer-container', {
                    layoutIsExpanded: false,
                    layoutShowControls: false,
                    layoutShowLeftPanel: false,
                    layoutShowSequence: false,
                    layoutShowLog: false,
                    viewportShowExpand: false,
                    viewportShowSelectionMode: false,
                    viewportShowAnimation: false
                });
                console.log('Main viewer (re)initialized successfully');
                
                // Ensure canvas is visible
                setTimeout(() => {
                    const newCanvas = viewerContainer.querySelector('canvas');
                    if (newCanvas) {
                        newCanvas.style.display = 'block';
                        newCanvas.style.visibility = 'visible';
                        console.log('New canvas made visible');
                    }
                }, 100);
                
            } catch (error) {
                console.error('Failed to reinitialize main viewer:', error);
                alert('Failed to reinitialize viewer. Please refresh the page.');
                return;
            }
            
            // Load structure in main viewer
            if (loadedFiles.length > 0) {
                // If no specific file selected, use the first file
                const fileIndex = currentFileIndex !== -1 ? currentFileIndex : 0;
                const file = loadedFiles[fileIndex];
                
                if (file && file.data) {
                    console.log('Loading file in single view:', file.name);
                    try {
                        // Update currentFileIndex if it was -1
                        if (currentFileIndex === -1) {
                            currentFileIndex = fileIndex;
                        }
                        
                        await parseStructureFile(file.data, file.format, false);

                        // Apply current illustrative style if enabled
                        if (illustrativeStyleEnabled) {
                            await applyIllustrativeStyle(true);
                        }

                        // Force viewer refresh and resize
                        setTimeout(() => {
                            if (viewer && viewer.plugin) {
                                try {
                                    // Check if canvas exists
                                    const canvas = viewerContainer.querySelector('canvas');
                                    console.log('Canvas found:', !!canvas);

                                    if (canvas) {
                                        canvas.style.display = 'block';
                                        canvas.style.visibility = 'visible';
                                    }

                                    // Trigger window resize event to ensure proper rendering
                                    window.dispatchEvent(new Event('resize'));

                                    viewer.handleResize();
                                    viewer.plugin.managers.camera.reset();

                                    console.log('Viewer refreshed and camera reset');
                                } catch (refreshError) {
                                    console.error('Error refreshing viewer:', refreshError);
                                }
                            }
                        }, 200);
                        
                        updateFileHistory();
                    } catch (error) {
                        console.error('Error loading structure in single view:', error);
                        // Show error in viewer
                        if (viewer) {
                            document.getElementById('atom-count').textContent = 'Error';
                        }
                    }
                } else {
                    console.warn('No valid file data found for single view');
                }
            } else {
                console.log('No files loaded');
                // Clear the main viewer if no files
                if (viewer) {
                    await viewer.plugin.clear();
                    document.getElementById('atom-count').textContent = '0';
                }
            }
        }
        
        // Old parsing functions removed - replaced by Molstar implementation above

        // Atom size/opacity functions removed - using cartoon mode only



        // Update file history UI
        function updateFileHistory() {
            const historyContainer = document.getElementById('file-history');
            // Preserve scroll position if possible
            const currentScrollTop = historyContainer.scrollTop;
            historyContainer.innerHTML = ''; // Clear existing items

            if (loadedFiles.length === 0) {
                historyContainer.textContent = 'No files loaded.';
                document.getElementById('download-all-files').style.display = 'none';
                return;
            } else {
                document.getElementById('download-all-files').style.display = 'flex';
            }

            let activeItem = null; // Keep track of the active item element

            loadedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                if (index === currentFileIndex) {
                    fileItem.classList.add('active');
                    activeItem = fileItem; // Store the active item
                }
                
                // Create file content container
                const fileItemContent = document.createElement('div');
                fileItemContent.className = 'file-item-content';
                
                // Create file name element
                const fileName = document.createElement('span');
                fileName.className = 'file-item-name';
                fileName.textContent = file.name;
                fileItemContent.appendChild(fileName);
                
                // Add format badge
                const formatBadge = document.createElement('span');
                formatBadge.className = `format-badge ${file.format}`;
                formatBadge.textContent = file.format.toUpperCase();
                fileItemContent.appendChild(formatBadge);
                
                fileItem.appendChild(fileItemContent);
                
                // Add download icon only for remote or predicted files
                if (file.source === 'remote' || file.source === 'predicted') {
                    const downloadIcon = document.createElement('div');
                    downloadIcon.className = 'file-download-icon';
                    downloadIcon.title = 'Download file';
                    downloadIcon.innerHTML = `
                        <svg viewBox="0 0 24 24">
                            <path d="M12 15.5l-3.5-3.5h2.5v-6h2v6h2.5l-3.5 3.5zm7.5 3.5h-15v-2h15v2z"/>
                        </svg>
                    `;
                    downloadIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        downloadFile(index);
                    });
                    fileItem.appendChild(downloadIcon);
                }
                
                fileItem.title = file.name;

                fileItem.addEventListener('click', async () => {
                    if (currentFileIndex === index) return;

                    currentFileIndex = index;
                    
                    // Check if we're in dual session mode and need to update it
                    if (currentSessionMode === 'dual' && sequenceAlignmentEnabled) {
                        // Find if current file has a corresponding sequence to maintain dual session
                        const matchingSequence = parsedSequences.find(seq => {
                            const match = findMatchingStructure(seq.header);
                            return match && match.name === file.name;
                        });
                        
                        if (matchingSequence && matchingSequence.status === 'completed') {
                            // Update dual session with new file and its predicted structure
                            await loadDualSessionStructures(matchingSequence, file);
                        } else {
                            // No matching sequence, fall back to single mode
                            await initializeSingleSessionMode();
                            parseStructureFile(file.data, file.format, false);
                        }
                    } else {
                        // Normal single session mode
                        parseStructureFile(file.data, file.format, false); // Don't maintain view
                    }
                    
                    updateFileHistory(); // Update highlighting
                    updateReferenceStructureDropdown(); // Update alignment dropdown

                    const diffusionIndex = diffusionSteps.findIndex(step => step.name === file.name);
                    if (diffusionIndex !== -1) {
                        currentStepIndex = diffusionIndex;
                        initializeAnimationControls();
                        document.getElementById('animation-controls').style.display = 'block';
                    } else {
                        document.getElementById('animation-controls').style.display = 'none';
                        stopAnimation();
                    }
                });
                historyContainer.appendChild(fileItem);
            });

            // Restore scroll position or scroll active item into view
            if (activeItem) {
                 // Check if active item is visible, if not, scroll to it
                const containerRect = historyContainer.getBoundingClientRect();
                const itemRect = activeItem.getBoundingClientRect();
                if (itemRect.top < containerRect.top || itemRect.bottom > containerRect.bottom) {
                    activeItem.scrollIntoView({ behavior: 'auto', block: 'nearest' });
                } else {
                    // If it was already visible, try restoring previous scroll position
                     historyContainer.scrollTop = currentScrollTop;
                }
            } else {
                 // Fallback if no active item somehow
                 historyContainer.scrollTop = currentScrollTop;
            }
        }

        // Download individual file
        function downloadFile(index) {
            if (index < 0 || index >= loadedFiles.length) return;
            
            const file = loadedFiles[index];
            const extension = file.format === 'mmcif' ? 'cif' : file.format;
            const filename = file.name.includes('.') ? file.name : `${file.name}.${extension}`;
            
            vscode.postMessage({
                command: 'downloadStructure',
                data: file.data,
                filename: filename,
                format: file.format
            });
        }

        // Download all files as ZIP
        function downloadAllFiles() {
            if (loadedFiles.length === 0) {
                vscode.postMessage({
                    command: 'showError',
                    message: 'No files to download'
                });
                return;
            }

            // Create ZIP file content
            const zip = new JSZip();
            
            loadedFiles.forEach((file, index) => {
                const extension = file.format === 'mmcif' ? 'cif' : file.format;
                const filename = file.name.includes('.') ? file.name : `${file.name}.${extension}`;
                zip.file(filename, file.data);
            });

            // Generate ZIP and download
            zip.generateAsync({type: 'blob'}).then(function(content) {
                const reader = new FileReader();
                reader.onload = function() {
                    const base64Data = reader.result.split(',')[1];
                    
                    vscode.postMessage({
                        command: 'downloadZipFile',
                        data: base64Data,
                        filename: `protein_structures_${Date.now()}.zip`
                    });
                };
                reader.readAsDataURL(content);
            }).catch(function(error) {
                console.error('Error creating ZIP file:', error);
                vscode.postMessage({
                    command: 'showError',
                    message: 'Error creating ZIP file: ' + error.message
                });
            });
        }

        // Handle Key Down for Navigation (update needed for sorted list)
         function handleKeyDown(event) {
             if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'BUTTON')) return;
             if (loadedFiles.length === 0) return;

             let newIndex = currentFileIndex;
             let indexChanged = false;

             if (event.key === 'ArrowUp') {
                 event.preventDefault();
                 if (currentFileIndex > 0) { newIndex = currentFileIndex - 1; indexChanged = true; }
                 // Optional: Wrap around to bottom
                 // else if (currentFileIndex === 0) { newIndex = loadedFiles.length - 1; indexChanged = true; }
             } else if (event.key === 'ArrowDown') {
                 event.preventDefault();
                 if (currentFileIndex < loadedFiles.length - 1) { newIndex = currentFileIndex + 1; indexChanged = true; }
                 // Optional: Wrap around to top
                 // else if (currentFileIndex === loadedFiles.length - 1) { newIndex = 0; indexChanged = true; }
             }

             if (indexChanged) {
                 currentFileIndex = newIndex; // newIndex is now the correct index in the *sorted* list
                 const selectedFile = loadedFiles[currentFileIndex];
                 
                 // Handle dual session mode for keyboard navigation too
                 (async () => {
                     if (currentSessionMode === 'dual' && sequenceAlignmentEnabled) {
                         // Find if current file has a corresponding sequence to maintain dual session
                         const matchingSequence = parsedSequences.find(seq => {
                             const match = findMatchingStructure(seq.header);
                             return match && match.name === selectedFile.name;
                         });
                         
                         if (matchingSequence && matchingSequence.status === 'completed') {
                             // Update dual session with new file and its predicted structure
                             await loadDualSessionStructures(matchingSequence, selectedFile);
                         } else {
                             // No matching sequence, fall back to single mode
                             await initializeSingleSessionMode();
                             parseStructureFile(selectedFile.data, selectedFile.format, false);
                         }
                     } else {
                         // Normal single session mode
                         parseStructureFile(selectedFile.data, selectedFile.format, false); // Don't maintain view
                     }
                 })();
                 
                 updateFileHistory(); // Update highlighting and scroll

                 const diffusionIndex = diffusionSteps.findIndex(step => step.name === selectedFile.name);
                 if (diffusionIndex !== -1) {
                     currentStepIndex = diffusionIndex; // Index within diffusionSteps array
                     initializeAnimationControls();
                     document.getElementById('animation-controls').style.display = 'block';
                 } else {
                     document.getElementById('animation-controls').style.display = 'none';
                     stopAnimation();
                 }
             }
         }


        // ===== SEQUENCE ALIGNMENT FUNCTIONS =====
        
        // Toggle sequence alignment section
        function toggleSequenceAlignment() {
            const toggle = document.getElementById('seq-alignment-toggle');
            const content = document.getElementById('seq-alignment-content');
            
            sequenceAlignmentEnabled = toggle.checked;
            
            if (sequenceAlignmentEnabled) {
                content.classList.add('active');
                
                // Auto-enable seq structure only mode if no structures are loaded
                if (loadedFiles.length === 0) {
                    document.getElementById('seq-only-radio').checked = true;
                    currentDisplayMode = 'seq-only';
                }
                
                updateViewerConfigForAlignment();
            } else {
                content.classList.remove('active');
                resetViewerConfig();
            }
        }
        
        // Set input mode (FASTA or single sequence)
        function setInputMode(mode) {
            currentInputMode = mode;
            
            const fastaBtn = document.getElementById('fasta-mode');
            const singleBtn = document.getElementById('single-mode');
            const fastaSection = document.getElementById('fasta-input-section');
            const singleSection = document.getElementById('single-input-section');
            
            if (mode === 'fasta') {
                fastaBtn.classList.add('active');
                singleBtn.classList.remove('active');
                fastaSection.style.display = 'block';
                singleSection.style.display = 'none';
            } else {
                fastaBtn.classList.remove('active');
                singleBtn.classList.add('active');
                fastaSection.style.display = 'none';
                singleSection.style.display = 'block';
            }
        }
        
        // Handle FASTA file upload
        function handleFastaFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('fasta-textarea').value = e.target.result;
                    parseFastaInput();
                };
                reader.readAsText(file);
            }
        }
        
        // Parse FASTA input
        function parseFastaInput() {
            const fastaText = document.getElementById('fasta-textarea').value.trim();
            if (!fastaText) {
                alert('Please provide FASTA sequences');
                return;
            }

            try {
                const newSequences = parseFasta(fastaText);
                if (newSequences.length === 0) {
                    alert('No valid FASTA sequences found');
                    return;
                }

                parsedSequences = [...parsedSequences, ...newSequences];
                updateSequenceList();
                showParsedSequencesSection();
                console.log(`Successfully parsed ${newSequences.length} sequences`);
                
            } catch (error) {
                alert('Error parsing FASTA: ' + error.message);
            }
        }
        
        // Parse FASTA text into sequence objects
        function parseFasta(fastaText) {
            const lines = fastaText.split('\n').map(line => line.trim()).filter(line => line);
            const sequences = [];
            let currentSeq = null;

            for (const line of lines) {
                if (line.startsWith('>')) {
                    if (currentSeq) {
                        sequences.push(currentSeq);
                    }
                    currentSeq = {
                        header: line.substring(1),
                        sequence: '',
                        status: 'pending',
                        pdbData: null,
                        error: null,
                        matchedStructure: null,
                        rmsdScore: null
                    };
                } else if (currentSeq) {
                    currentSeq.sequence += line.replace(/[^A-Za-z]/g, '').toUpperCase();
                }
            }

            if (currentSeq) {
                sequences.push(currentSeq);
            }

            // Validate sequences
            return sequences.filter(seq => {
                if (seq.sequence.length < 10) {
                    console.warn(`Skipping sequence ${seq.header}: too short (${seq.sequence.length} residues)`);
                    return false;
                }
                if (seq.sequence.length > 1000) {
                    console.warn(`Skipping sequence ${seq.header}: too long (${seq.sequence.length} residues)`);
                    return false;
                }
                return true;
            });
        }
        
        // Add single sequence
        function addSingleSequence() {
            const name = document.getElementById('sequence-name').value.trim();
            const sequence = document.getElementById('single-sequence-textarea').value.trim().replace(/[^A-Za-z]/g, '').toUpperCase();
            
            if (!name || !sequence) {
                alert('Please provide both sequence name and sequence');
                return;
            }
            
            if (sequence.length < 10) {
                alert('Sequence too short (minimum 10 residues)');
                return;
            }
            
            if (sequence.length > 1000) {
                alert('Sequence too long (maximum 1000 residues)');
                return;
            }
            
            const newSequence = {
                header: name,
                sequence: sequence,
                status: 'pending',
                pdbData: null,
                error: null,
                matchedStructure: null,
                rmsdScore: null
            };
            
            parsedSequences.push(newSequence);
            updateSequenceList();
            showParsedSequencesSection();
            
            // Clear inputs
            document.getElementById('sequence-name').value = '';
            document.getElementById('single-sequence-textarea').value = '';
        }
        
        // Update sequence list UI
        function updateSequenceList() {
            const listContainer = document.getElementById('sequence-list');
            const countElement = document.getElementById('sequence-count');
            
            countElement.textContent = parsedSequences.length;

            if (parsedSequences.length === 0) {
                listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: hsl(220, 9%, 46%);">No sequences parsed yet</div>';
                return;
            }

            listContainer.innerHTML = parsedSequences.map((seq, index) => `
                <div class="sequence-item ${seq.status} ${selectedSequenceIndex === index ? 'active' : ''}" onclick="selectSequence(${index})">
                    <div class="sequence-name">
                        <div class="sequence-name-content">
                            <span>${seq.header}</span>
                            ${seq.status === 'completed' ? `
                                <div class="sequence-download-icon" onclick="event.stopPropagation(); downloadSequencePDB(${index})" title="Download PDB">
                                    <svg viewBox="0 0 24 24">
                                        <path d="M12 15.5l-3.5-3.5h2.5v-6h2v6h2.5l-3.5 3.5zm7.5 3.5h-15v-2h15v2z"/>
                                    </svg>
                                </div>
                            ` : ''}
                        </div>
                        ${seq.rmsdScore ? `<div class="sequence-rmsd-section"><span class="rmsd-score">RMSD: ${seq.rmsdScore.toFixed(3)}Å</span></div>` : ''}
                    </div>
                    <div class="sequence-preview">${seq.sequence.substring(0, 40)}${seq.sequence.length > 40 ? '...' : ''}</div>
                    <div class="sequence-status">
                        ${getSequenceStatusText(seq)} (${seq.sequence.length} residues)
                    </div>
                </div>
            `).join('');
        }
        
        // Get status text for sequence
        function getSequenceStatusText(seq) {
            switch (seq.status) {
                case 'pending': return 'Ready to fold';
                case 'loading': return 'Folding with ESMFold...';
                case 'completed': return 'Structure ready';
                case 'error': return `Error: ${seq.error}`;
                default: return 'Unknown status';
            }
        }
        
        // Show parsed sequences section
        function showParsedSequencesSection() {
            document.getElementById('parsed-sequences-section').style.display = 'block';
            document.getElementById('align-mode-section').style.display = 'block';
        }
        
        // Select sequence
        function selectSequence(index) {
            selectedSequenceIndex = index;
            updateSequenceList();
            
            const seq = parsedSequences[index];
            if (seq.status === 'completed' && seq.pdbData) {
                displaySequenceStructure(seq);
            } else if (seq.status === 'pending') {
                foldSequence(index);
            }
        }
        
        // Fold all sequences
        async function foldAllSequences() {
            const pendingSequences = parsedSequences.filter(seq => seq.status === 'pending');
            if (pendingSequences.length === 0) {
                alert('No pending sequences to fold');
                return;
            }

            for (let i = 0; i < parsedSequences.length; i++) {
                if (parsedSequences[i].status === 'pending') {
                    await foldSequence(i);
                    // Add a small delay to avoid overwhelming the API
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }
        
        // Fold single sequence using ESMFold API
        async function foldSequence(index) {
            const seq = parsedSequences[index];
            seq.status = 'loading';
            updateSequenceList();

            try {
                console.log(`Folding sequence: ${seq.header}`);
                
                const response = await fetch('https://api.esmatlas.com/foldSequence/v1/pdb/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain',
                    },
                    body: seq.sequence
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }

                const pdbData = await response.text();
                
                if (!pdbData || !pdbData.includes('ATOM')) {
                    throw new Error('Invalid PDB data received from API');
                }

                seq.pdbData = pdbData;
                seq.status = 'completed';
                
                // Add predicted structure to loadedFiles for download functionality
                const predictedFileName = `${seq.header}_predicted.pdb`;
                const existingIndex = loadedFiles.findIndex(f => f.name === predictedFileName);
                
                if (existingIndex !== -1) {
                    // Update existing predicted structure
                    loadedFiles[existingIndex] = {
                        name: predictedFileName,
                        data: pdbData,
                        format: 'pdb',
                        isPredicted: true
                    };
                } else {
                    // Add new predicted structure
                    loadedFiles.push({
                        name: predictedFileName,
                        data: pdbData,
                        format: 'pdb',
                        source: 'predicted', // ESMFold predictions
                        isPredicted: true
                    });
                }
                
                // Try to match with existing structures
                seq.matchedStructure = findMatchingStructure(seq.header);
                
                if (selectedSequenceIndex === index) {
                    await displaySequenceStructure(seq);
                }

                console.log(`Successfully folded ${seq.header}`);

            } catch (error) {
                console.error('Error folding sequence:', error);
                seq.status = 'error';
                seq.error = error.message;
            } finally {
                updateSequenceList();
            }
        }
        
        // Find matching structure based on sequence name
        function findMatchingStructure(sequenceName) {
            if (!sequenceName || loadedFiles.length === 0) return null;
            
            // Phase 1: Strict name matching (ignore only file extension)
            // If sequence name is "sample_0", look for exactly "sample_0.pdb" or "sample_0.cif"
            let match = loadedFiles.find(file => {
                // Remove file extension from filename
                const fileNameWithoutExt = file.name.replace(/\.(pdb|cif|mmcif|pdbqt|gro|xyz|mol|mol2|sdf)$/i, '');
                // Case insensitive exact comparison
                return fileNameWithoutExt.toLowerCase() === sequenceName.toLowerCase();
            });
            
            if (match) {
                console.log(`Strict match found: ${match.name} for sequence ${sequenceName}`);
                return match;
            }
            
            // Phase 2: Partial matching (fallback) - only if strict matching fails
            console.log(`No strict match found for ${sequenceName}, trying partial matching...`);
            
            // Normalize sequence name for partial matching
            const normalizedSeqName = sequenceName.toLowerCase().replace(/[^a-z0-9]/g, '');
            
            match = loadedFiles.find(file => {
                const normalizedFileName = file.name.toLowerCase().replace(/[^a-z0-9]/g, '');
                
                // Check if filename contains sequence name or vice versa
                if (normalizedFileName.includes(normalizedSeqName) || normalizedSeqName.includes(normalizedFileName)) {
                    return true;
                }
                
                // Try extracting PDB ID patterns (4 characters) from both
                const seqPdbId = normalizedSeqName.match(/[a-z0-9]{4}/);
                const filePdbId = normalizedFileName.match(/[a-z0-9]{4}/);
                
                if (seqPdbId && filePdbId && seqPdbId[0] === filePdbId[0]) {
                    return true;
                }
                
                // Try matching with common separators replaced
                const seqParts = sequenceName.toLowerCase().split(/[-_\s\.]+/);
                const fileParts = file.name.toLowerCase().split(/[-_\s\.]+/);
                
                for (const seqPart of seqParts) {
                    for (const filePart of fileParts) {
                        if (seqPart.length > 2 && filePart.length > 2 && 
                            (seqPart.includes(filePart) || filePart.includes(seqPart))) {
                            return true;
                        }
                    }
                }
                
                return false;
            });
            
            if (match) {
                console.log(`Partial match found: ${match.name} for sequence ${sequenceName}`);
                return match;
            }
            
            console.log(`No matching structure found for sequence: ${sequenceName}`);
            return null;
        }
        
        // Display sequence structure in viewer
        async function displaySequenceStructure(seq) {
            if (!seq.pdbData) return;
            
            try {
                // Update currentFileIndex to point to the predicted structure for download functionality
                const predictedFileName = `${seq.header}_predicted.pdb`;
                const predictedFileIndex = loadedFiles.findIndex(f => f.name === predictedFileName);
                if (predictedFileIndex !== -1) {
                    currentFileIndex = predictedFileIndex;
                }
                
                // Find matching structure for this sequence
                const matchedStructure = findMatchingStructure(seq.header);
                
                if (currentDisplayMode === 'align' && matchedStructure) {
                    // Align mode: reinitialize viewer with alignment tools enabled
                    await initializeAlignmentMode();
                    await loadStructuresForAlignment(seq, matchedStructure);
                } else if (currentDisplayMode === 'seq-only') {
                    // Seq structure only mode: show only predicted structure
                    await initializeSingleSessionMode();
                    await loadPredictedStructure(seq.pdbData);
                } else if (currentDisplayMode === 'dual' && matchedStructure) {
                    // Dual session mode: show original structure on left, predicted on right
                    await initializeDualSessionMode();
                    await loadDualSessionStructures(seq, matchedStructure);
                } else {
                    // Fallback to single mode: show only predicted structure
                    await initializeSingleSessionMode();
                    await loadPredictedStructure(seq.pdbData);
                }
            } catch (error) {
                console.error('Error displaying sequence structure:', error);
            }
        }
        
        // ========== Structure Alignment UI Functions ==========
        
        // Update reference structure dropdown
        function updateReferenceStructureDropdown() {
            const select = document.getElementById('reference-structure-select');
            const currentValue = select.value;
            select.innerHTML = '<option value="">Select reference structure...</option>';
            
            loadedFiles.forEach((file, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = file.name;
                if (index.toString() === currentValue) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            
            updateAlignmentButtonState();
        }
        
        // Update alignment button state
        function updateAlignmentButtonState() {
            const select = document.getElementById('reference-structure-select');
            const alignBtn = document.getElementById('align-structures-btn');
            const hasReference = select.value !== '' && select.value !== null;
            const hasMultipleFiles = loadedFiles.length >= 2;
            alignBtn.disabled = !hasReference || !hasMultipleFiles;
        }
        
        // Main structure alignment function
        async function performStructureAlignment() {
            const referenceIndex = parseInt(document.getElementById('reference-structure-select').value);
            if (isNaN(referenceIndex) || referenceIndex < 0 || referenceIndex >= loadedFiles.length) {
                alert('Please select a valid reference structure.');
                return;
            }
            
            if (loadedFiles.length < 2) {
                alert('Please load at least 2 structures for alignment.');
                return;
            }
            
            const referenceFile = loadedFiles[referenceIndex];
            const otherFiles = loadedFiles.filter((_, idx) => idx !== referenceIndex);
            
            try {
                // Show loading indicator
                const alignBtn = document.getElementById('align-structures-btn');
                alignBtn.disabled = true;
                alignBtn.textContent = 'Aligning...';
                
                // Extract sequences and CA atoms from reference
                let refSequence, refCAAtoms;
                if (referenceFile.format === 'mmcif' || referenceFile.format === 'cif') {
                    refSequence = extractSequenceFromCIF(referenceFile.data);
                    refCAAtoms = extractCAAtomsFromCIF(referenceFile.data);
                } else {
                    refSequence = extractSequenceFromPDB(referenceFile.data);
                    refCAAtoms = extractCAAtoms(referenceFile.data);
                }
                
                if (refSequence.length === 0 || refCAAtoms.length === 0) {
                    throw new Error(`Failed to extract sequence or CA atoms from reference file: ${referenceFile.name}`);
                }
                
                const refSeqString = refSequence.map(s => s.residue).join('');
                console.log(`Reference: ${refSequence.length} residues, ${refCAAtoms.length} CA atoms`);
                
                // Store alignment results (reference trimming info will be added per alignment)
                alignmentData = {
                    reference: {
                        file: referenceFile,
                        sequence: refSequence,
                        seqString: refSeqString,
                        caAtoms: refCAAtoms,
                        index: referenceIndex
                    },
                    aligned: []
                };
                
                // Align each structure to reference
                for (const file of otherFiles) {
                    let seq, caAtoms;
                    if (file.format === 'mmcif' || file.format === 'cif') {
                        seq = extractSequenceFromCIF(file.data);
                        caAtoms = extractCAAtomsFromCIF(file.data);
                    } else {
                        seq = extractSequenceFromPDB(file.data);
                        caAtoms = extractCAAtoms(file.data);
                    }
                    
                    if (seq.length === 0 || caAtoms.length === 0) {
                        console.warn(`Failed to extract sequence or CA atoms from: ${file.name}, skipping...`);
                        continue;
                    }
                    
                    const seqString = seq.map(s => s.residue).join('');
                    console.log(`Aligning ${file.name}: ${seq.length} residues, ${caAtoms.length} CA atoms`);
                    
                    // Perform LOCAL sequence alignment using Smith-Waterman
                    const localAlignment = smithWaterman(refSeqString, seqString);
                    console.log(`Local alignment score: ${localAlignment.score}`);
                    console.log(`Aligned region - Reference: ${localAlignment.refStart}-${localAlignment.refEnd} (${localAlignment.refEnd - localAlignment.refStart + 1} residues)`);
                    console.log(`Aligned region - Query: ${localAlignment.queryStart}-${localAlignment.queryEnd} (${localAlignment.queryEnd - localAlignment.queryStart + 1} residues)`);
                    
                    // Validate that we found a valid alignment
                    if (localAlignment.refStart === -1 || localAlignment.queryStart === -1 || 
                        localAlignment.refEnd === -1 || localAlignment.queryEnd === -1) {
                        console.warn(`No valid local alignment found for ${file.name}, skipping...`);
                        continue;
                    }
                    
                    // Extract trimmed sequences (only the aligned region)
                    // Both sequences are trimmed to their respective aligned regions
                    const trimmedRefSequence = refSequence.slice(localAlignment.refStart, localAlignment.refEnd + 1);
                    const trimmedQuerySequence = seq.slice(localAlignment.queryStart, localAlignment.queryEnd + 1);
                    const trimmedRefSeqString = trimmedRefSequence.map(s => s.residue).join('');
                    const trimmedQuerySeqString = trimmedQuerySequence.map(s => s.residue).join('');
                    
                    console.log(`Trimmed sequences - Reference: ${trimmedRefSequence.length} residues (positions ${localAlignment.refStart + 1}-${localAlignment.refEnd + 1}), Query: ${trimmedQuerySequence.length} residues (positions ${localAlignment.queryStart + 1}-${localAlignment.queryEnd + 1})`);
                    
                    // Extract CA atoms only for the aligned regions
                    const trimmedRefCAAtoms = extractCAAtomsForRegion(
                        refSequence, refCAAtoms, 
                        localAlignment.refStart, localAlignment.refEnd
                    );
                    const trimmedQueryCAAtoms = extractCAAtomsForRegion(
                        seq, caAtoms,
                        localAlignment.queryStart, localAlignment.queryEnd
                    );
                    
                    console.log(`Trimmed CA atoms - Reference: ${trimmedRefCAAtoms.length}, Query: ${trimmedQueryCAAtoms.length}`);
                    
                    if (trimmedRefCAAtoms.length === 0 || trimmedQueryCAAtoms.length === 0) {
                        console.warn(`No CA atoms found in aligned region for ${file.name}, skipping alignment...`);
                        continue;
                    }
                    
                    // Debug: Check B-factor availability
                    const refWithBFactor = trimmedRefCAAtoms.filter(a => a.bFactor !== null && a.bFactor !== undefined).length;
                    const queryWithBFactor = trimmedQueryCAAtoms.filter(a => a.bFactor !== null && a.bFactor !== undefined).length;
                    console.log(`B-factor data: Reference has ${refWithBFactor}/${trimmedRefCAAtoms.length} atoms with B-factor, Query has ${queryWithBFactor}/${trimmedQueryCAAtoms.length}`);
                    
                    if (refWithBFactor > 0) {
                        const refBFactors = trimmedRefCAAtoms.filter(a => a.bFactor !== null && a.bFactor !== undefined).map(a => a.bFactor);
                        console.log(`  Reference B-factor range: ${Math.min(...refBFactors).toFixed(1)} - ${Math.max(...refBFactors).toFixed(1)}`);
                    }
                    if (queryWithBFactor > 0) {
                        const queryBFactors = trimmedQueryCAAtoms.filter(a => a.bFactor !== null && a.bFactor !== undefined).map(a => a.bFactor);
                        console.log(`  Query B-factor range: ${Math.min(...queryBFactors).toFixed(1)} - ${Math.max(...queryBFactors).toFixed(1)}`);
                    }
                    
                    // Filter by B-factor to use only high-confidence atoms for alignment
                    // Lower B-factor = higher confidence (typical range: 20-100, < 50 is very good)
                    // Use adaptive threshold: if too many atoms are filtered, use a more lenient threshold
                    let MAX_B_FACTOR = 80;  // Start with a reasonable threshold
                    let refFiltered = filterAtomsByBFactor(trimmedRefCAAtoms, MAX_B_FACTOR);
                    let queryFiltered = filterAtomsByBFactor(trimmedQueryCAAtoms, MAX_B_FACTOR);
                    
                    console.log(`B-factor filtering (initial threshold=${MAX_B_FACTOR}):`);
                    console.log(`  Reference: ${refFiltered.kept}/${refFiltered.total} atoms kept (${refFiltered.filteredOut} filtered out)`);
                    console.log(`  Query: ${queryFiltered.kept}/${queryFiltered.total} atoms kept (${queryFiltered.filteredOut} filtered out)`);
                    
                    // Adaptive threshold: if we're filtering out too many atoms, relax the threshold
                    const MIN_ATOMS_REQUIRED = Math.min(trimmedRefCAAtoms.length, trimmedQueryCAAtoms.length) * 0.3; // Need at least 30% of atoms
                    
                    if (refFiltered.kept < MIN_ATOMS_REQUIRED || queryFiltered.kept < MIN_ATOMS_REQUIRED) {
                        console.warn(`Too many atoms filtered out. Relaxing B-factor threshold...`);
                        
                        // Try progressively higher thresholds until we have enough atoms
                        const thresholds = [100, 150, 200, 300, Infinity];
                        let foundThreshold = false;
                        
                        for (const threshold of thresholds) {
                            refFiltered = filterAtomsByBFactor(trimmedRefCAAtoms, threshold);
                            queryFiltered = filterAtomsByBFactor(trimmedQueryCAAtoms, threshold);
                            
                            console.log(`  Trying threshold=${threshold}: Ref=${refFiltered.kept}, Query=${queryFiltered.kept}`);
                            
                            if (refFiltered.kept >= MIN_ATOMS_REQUIRED && queryFiltered.kept >= MIN_ATOMS_REQUIRED) {
                                MAX_B_FACTOR = threshold;
                                foundThreshold = true;
                                console.log(`  Using threshold=${threshold} (Ref: ${refFiltered.kept}, Query: ${queryFiltered.kept})`);
                                break;
                            }
                        }
                        
                        // If even with no threshold we don't have enough, disable filtering
                        if (!foundThreshold || MAX_B_FACTOR === Infinity) {
                            console.warn(`B-factor filtering disabled - using all atoms regardless of B-factor`);
                            // Create maps with all atoms (no filtering)
                            refFiltered = { filtered: trimmedRefCAAtoms, kept: trimmedRefCAAtoms.length, total: trimmedRefCAAtoms.length, filteredOut: 0 };
                            queryFiltered = { filtered: trimmedQueryCAAtoms, kept: trimmedQueryCAAtoms.length, total: trimmedQueryCAAtoms.length, filteredOut: 0 };
                        }
                    }
                    
                    // Create maps for filtered atoms (for faster lookup in mapping function)
                    const refFilteredMap = new Map();
                    refFiltered.filtered.forEach(atom => {
                        const key = `${atom.chainId || 'A'}_${atom.residueNumber}`;
                        refFilteredMap.set(key, atom);
                    });
                    
                    const queryFilteredMap = new Map();
                    queryFiltered.filtered.forEach(atom => {
                        const key = `${atom.chainId || 'A'}_${atom.residueNumber}`;
                        queryFilteredMap.set(key, atom);
                    });
                    
                    // Now map the aligned sequences (with gaps) to the filtered CA atoms
                    // Only use atoms that passed B-factor filtering (if enabled)
                    const alignedCA = mapAlignedSequencesToAtomsWithFilter(
                        trimmedRefSequence, trimmedQuerySequence,
                        localAlignment.aligned1, localAlignment.aligned2,
                        refFilteredMap, queryFilteredMap,
                        0  // No identity filtering - use all gap-free positions
                    );
                    
                    if (alignedCA.ref.length === 0 || alignedCA.query.length === 0) {
                        console.warn(`No matching atoms found for ${file.name}, skipping alignment...`);
                        continue;
                    }
                    
                    // Validation checks
                    const MIN_ALIGNED_RESIDUES = 50;  // Minimum number of aligned residues
                    const stats = alignedCA.stats;
                    
                    console.log(`\n=== Alignment Statistics for ${file.name} ===`);
                    console.log(`  Aligned region - Reference: positions ${localAlignment.refStart + 1}-${localAlignment.refEnd + 1} (${localAlignment.refEnd - localAlignment.refStart + 1} residues)`);
                    console.log(`  Aligned region - Query: positions ${localAlignment.queryStart + 1}-${localAlignment.queryEnd + 1} (${localAlignment.queryEnd - localAlignment.queryStart + 1} residues)`);
                    console.log(`  Matched atom pairs: ${alignedCA.ref.length}`);
                    console.log(`  Total aligned positions: ${stats.totalAligned}`);
                    console.log(`  Matched positions (no gaps): ${stats.matchedPositions}`);
                    console.log(`  Identical residues: ${stats.identicalPositions} (${stats.sequenceIdentity.toFixed(1)}% identity)`);
                    console.log(`  Reference gaps: ${stats.refGaps}`);
                    console.log(`  Query gaps: ${stats.queryGaps}`);
                    console.log(`  Coverage: ${stats.coverage.toFixed(1)}% of shorter sequence (${stats.shorterSeqLength} residues)`);
                    
                    // Validate alignment quality
                    if (alignedCA.ref.length < MIN_ALIGNED_RESIDUES) {
                        console.warn(`WARNING: Only ${alignedCA.ref.length} aligned residues found (minimum: ${MIN_ALIGNED_RESIDUES}).`);
                        console.warn(`  This alignment may be unreliable. Consider checking sequence homology.`);
                        // Continue anyway, but log the warning
                    }
                    
                    // Perform structural alignment using Kabsch algorithm (single pass - optimal solution)
                    console.log(`\nPerforming structural alignment with ${alignedCA.ref.length} atom pairs...`);
                    const transformation = kabschAlgorithm(alignedCA.ref, alignedCA.query);
                    
                    // Apply transformation to aligned CA atoms and calculate RMSD
                    const transformedQuery = applyTransformation(alignedCA.query, transformation.rotation, transformation.translation);
                    const rmsd = calculateRMSD(alignedCA.ref, transformedQuery);
                    
                    console.log(`  RMSD: ${rmsd.toFixed(2)} Å`);
                    console.log(`=== End Alignment Statistics ===\n`);
                    
                    // Apply transformation to ALL atoms in the query structure (for visualization)
                    // The transformation was calculated from the trimmed region, but we apply it to the full structure
                    const transformedAtoms = applyTransformation(caAtoms, transformation.rotation, transformation.translation);
                    
                    // Identify conserved regions (100% sequence identity) in the aligned region
                    const conservation = identifyConservedRegions(
                        localAlignment.aligned1, 
                        localAlignment.aligned2
                    );
                    
                    // Store alignment information including trimming details
                    alignmentData.aligned.push({
                        file: file,
                        sequence: seq,
                        seqString: seqString,
                        trimmedSequence: trimmedQuerySequence,
                        trimmedSeqString: trimmedQuerySeqString,
                        caAtoms: caAtoms,
                        trimmedCAAtoms: trimmedQueryCAAtoms,
                        transformedAtoms: transformedAtoms,
                        transformation: transformation,
                        sequenceAlignment: {
                            aligned1: localAlignment.aligned1,
                            aligned2: localAlignment.aligned2,
                            score: localAlignment.score
                        },
                        rmsd: rmsd,
                        conservation: conservation,
                        alignedCA: alignedCA,
                        alignmentStats: stats,
                        alignmentRegion: {
                            refStart: localAlignment.refStart,
                            refEnd: localAlignment.refEnd,
                            queryStart: localAlignment.queryStart,
                            queryEnd: localAlignment.queryEnd,
                            refTrimmedLength: trimmedRefSequence.length,
                            queryTrimmedLength: trimmedQuerySequence.length
                        }
                    });
                }
                
                if (alignmentData.aligned.length === 0) {
                    throw new Error('No structures could be aligned. Please check that files contain valid protein structures.');
                }
                
                // Visualize aligned structures
                await visualizeAlignedStructures();
                
                // Display results
                displayAlignmentResults();
                
                // Display sequence alignment
                displaySequenceAlignment();
                
            } catch (error) {
                console.error('Alignment error:', error);
                alert('Error during alignment: ' + error.message);
            } finally {
                const alignBtn = document.getElementById('align-structures-btn');
                alignBtn.disabled = false;
                alignBtn.textContent = 'Align Structures';
            }
        }
        
        // Calculate alignment statistics
        function calculateAlignmentStats(alignedRef, alignedQuery, refSeq, querySeq) {
            const totalAligned = alignedRef.length;
            let matchedPositions = 0;  // Positions where both sequences have residues (no gaps)
            let identicalPositions = 0; // Positions where residues are identical
            let refGaps = 0;
            let queryGaps = 0;
            
            for (let i = 0; i < totalAligned; i++) {
                const refChar = alignedRef[i];
                const queryChar = alignedQuery[i];
                
                if (refChar === '-') refGaps++;
                if (queryChar === '-') queryGaps++;
                
                if (refChar !== '-' && queryChar !== '-') {
                    matchedPositions++;
                    if (refChar === queryChar) {
                        identicalPositions++;
                    }
                }
            }
            
            const shorterSeqLength = Math.min(refSeq.length, querySeq.length);
            const coverage = shorterSeqLength > 0 ? (matchedPositions / shorterSeqLength) * 100 : 0;
            const sequenceIdentity = matchedPositions > 0 ? (identicalPositions / matchedPositions) * 100 : 0;
            
            return {
                totalAligned: totalAligned,
                matchedPositions: matchedPositions,
                identicalPositions: identicalPositions,
                refGaps: refGaps,
                queryGaps: queryGaps,
                coverage: coverage,
                sequenceIdentity: sequenceIdentity,
                shorterSeqLength: shorterSeqLength
            };
        }
        
        // Filter CA atoms by B-factor threshold
        // atoms: array of CA atom objects with bFactor property
        // maxBFactor: maximum B-factor to include (default: 80, typical range: 20-100)
        // Returns filtered atoms and statistics
        function filterAtomsByBFactor(atoms, maxBFactor = 80) {
            const filtered = [];
            let totalWithBFactor = 0;
            let filteredOut = 0;
            
            for (const atom of atoms) {
                if (atom.bFactor === null || atom.bFactor === undefined) {
                    // If B-factor is not available, include it (assume it's good)
                    filtered.push(atom);
                } else {
                    totalWithBFactor++;
                    if (atom.bFactor <= maxBFactor) {
                        filtered.push(atom);
                    } else {
                        filteredOut++;
                    }
                }
            }
            
            return {
                filtered: filtered,
                total: atoms.length,
                withBFactor: totalWithBFactor,
                filteredOut: filteredOut,
                kept: filtered.length
            };
        }
        
        // Extract CA atoms for a specific region of a sequence (by sequence index range)
        // sequence: array of sequence objects with residue, number, chain, name
        // caAtoms: array of CA atom objects
        // startIdx: start index in sequence (0-based, inclusive)
        // endIdx: end index in sequence (0-based, inclusive)
        function extractCAAtomsForRegion(sequence, caAtoms, startIdx, endIdx) {
            if (startIdx < 0 || endIdx >= sequence.length || startIdx > endIdx) {
                console.warn(`Invalid region: startIdx=${startIdx}, endIdx=${endIdx}, sequence length=${sequence.length}`);
                return [];
            }
            
            // Create map from (chain, residueNumber) to CA atom
            const atomMap = new Map();
            caAtoms.forEach((atom) => {
                const key = `${atom.chainId || 'A'}_${atom.residueNumber}`;
                if (!atomMap.has(key)) {
                    atomMap.set(key, atom);
                }
            });
            
            // Extract atoms for the specified region
            const regionAtoms = [];
            for (let i = startIdx; i <= endIdx; i++) {
                const residue = sequence[i];
                if (!residue) continue;
                
                const key = `${residue.chain || 'A'}_${residue.number}`;
                const atom = atomMap.get(key);
                
                if (atom) {
                    regionAtoms.push(atom);
                } else {
                    console.warn(`No CA atom found for residue ${residue.number} chain ${residue.chain} at sequence position ${i}`);
                }
            }
            
            return regionAtoms;
        }
        
        // Map aligned sequences to CA atoms using pre-filtered atom maps
        // This version uses pre-filtered atom maps (e.g., filtered by B-factor)
        // refSeq, querySeq: trimmed sequence arrays
        // alignedRef, alignedQuery: aligned sequence strings with gaps
        // refAtomMap, queryAtomMap: Maps from (chain_residueNumber) to CA atom (pre-filtered)
        // identityThreshold: optional sequence identity filtering (0 = no filtering)
        function mapAlignedSequencesToAtomsWithFilter(refSeq, querySeq, alignedRef, alignedQuery, refAtomMap, queryAtomMap, identityThreshold = 0) {
            const refAligned = [];
            const queryAligned = [];
            let refSeqIdx = 0;  // Index in trimmed refSeq array
            let querySeqIdx = 0; // Index in trimmed querySeq array
            
            // Map aligned sequences to atoms
            for (let i = 0; i < alignedRef.length; i++) {
                // Check if residues are identical (for identity filtering)
                const refChar = alignedRef[i];
                const queryChar = alignedQuery[i];
                const isIdentical = (refChar !== '-' && queryChar !== '-' && refChar === queryChar);
                
                let refAtom = null;
                let queryAtom = null;
                
                // Process reference sequence position
                if (refChar !== '-') {
                    if (refSeqIdx < refSeq.length) {
                        const refResidue = refSeq[refSeqIdx];
                        const refKey = `${refResidue.chain || 'A'}_${refResidue.number}`;
                        refAtom = refAtomMap.get(refKey);
                        
                        if (!refAtom) {
                            // Atom was filtered out (e.g., by B-factor) or not found
                            // Skip this position
                        }
                        
                        refSeqIdx++;
                    }
                }
                
                // Process query sequence position
                if (queryChar !== '-') {
                    if (querySeqIdx < querySeq.length) {
                        const queryResidue = querySeq[querySeqIdx];
                        const queryKey = `${queryResidue.chain || 'A'}_${queryResidue.number}`;
                        queryAtom = queryAtomMap.get(queryKey);
                        
                        if (!queryAtom) {
                            // Atom was filtered out (e.g., by B-factor) or not found
                            // Skip this position
                        }
                        
                        querySeqIdx++;
                    }
                }
                
                // Only include positions where both have atoms (no gaps, and both passed filtering)
                if (refAtom && queryAtom) {
                    if (identityThreshold > 0) {
                        // Filter: only include if residues are identical
                        if (isIdentical) {
                            refAligned.push(refAtom);
                            queryAligned.push(queryAtom);
                        }
                    } else {
                        // No filtering: include all matched positions
                        refAligned.push(refAtom);
                        queryAligned.push(queryAtom);
                    }
                }
            }
            
            if (refAligned.length === 0) {
                throw new Error('No matching atoms found after filtering. Try increasing B-factor threshold or check that structures have valid CA atoms.');
            }
            
            // Calculate statistics
            const stats = calculateAlignmentStats(alignedRef, alignedQuery, refSeq, querySeq);
            stats.matchedAtoms = refAligned.length;
            
            console.log(`Successfully mapped ${refAligned.length} atom pairs (after B-factor filtering)`);
            
            return { 
                ref: refAligned, 
                query: queryAligned,
                stats: stats
            };
        }
        
        // Map aligned sequences to CA atoms
        // This function maps sequence positions (not residue numbers) to CA atoms
        // Key insight: sequences are aligned by homology, not by residue number
        // Optionally filters by sequence identity threshold (0-100, where 0 = no filtering)
        function mapAlignedSequencesToAtoms(refCA, queryCA, alignedRef, alignedQuery, refSeq, querySeq, identityThreshold = 0) {
            const refAligned = [];
            const queryAligned = [];
            let refSeqIdx = 0;  // Index in original refSeq array
            let querySeqIdx = 0; // Index in original querySeq array
            
            // Create maps from (chain, residueNumber) to CA atom for faster lookup
            const refAtomMap = new Map();
            refCA.forEach((atom) => {
                const key = `${atom.chainId || 'A'}_${atom.residueNumber}`;
                if (!refAtomMap.has(key)) {
                    refAtomMap.set(key, atom);
                }
            });
            
            const queryAtomMap = new Map();
            queryCA.forEach((atom) => {
                const key = `${atom.chainId || 'A'}_${atom.residueNumber}`;
                if (!queryAtomMap.has(key)) {
                    queryAtomMap.set(key, atom);
                }
            });
            
            // Map aligned sequences to atoms
            // The aligned sequences have gaps ('-'), but we track position in original sequences
            for (let i = 0; i < alignedRef.length; i++) {
                // Check if residues are identical (for identity filtering) - check directly from aligned sequences
                const refChar = alignedRef[i];
                const queryChar = alignedQuery[i];
                const isIdentical = (refChar !== '-' && queryChar !== '-' && refChar === queryChar);
                
                let refAtom = null;
                let queryAtom = null;
                
                // Process reference sequence position
                if (refChar !== '-') {
                    // This position corresponds to refSeq[refSeqIdx]
                    if (refSeqIdx < refSeq.length) {
                        const refResidue = refSeq[refSeqIdx];
                        // Look up CA atom using chain and residue number from sequence
                        const refKey = `${refResidue.chain || 'A'}_${refResidue.number}`;
                        refAtom = refAtomMap.get(refKey);
                        
                        if (!refAtom) {
                            console.warn(`No CA atom found for ref residue ${refResidue.number} chain ${refResidue.chain} at sequence position ${refSeqIdx}`);
                        }
                        
                        refSeqIdx++; // Advance to next position in original sequence
                    }
                }
                
                // Process query sequence position
                if (queryChar !== '-') {
                    // This position corresponds to querySeq[querySeqIdx]
                    if (querySeqIdx < querySeq.length) {
                        const queryResidue = querySeq[querySeqIdx];
                        // Look up CA atom using chain and residue number from sequence
                        const queryKey = `${queryResidue.chain || 'A'}_${queryResidue.number}`;
                        queryAtom = queryAtomMap.get(queryKey);
                        
                        if (!queryAtom) {
                            console.warn(`No CA atom found for query residue ${queryResidue.number} chain ${queryResidue.chain} at sequence position ${querySeqIdx}`);
                        }
                        
                        querySeqIdx++; // Advance to next position in original sequence
                    }
                }
                
                // Only include positions where both have atoms (no gaps in either sequence)
                // Optionally filter by sequence identity if threshold is set
                if (refAtom && queryAtom) {
                    if (identityThreshold > 0) {
                        // Filter: only include if residues are identical
                        if (isIdentical) {
                    refAligned.push(refAtom);
                    queryAligned.push(queryAtom);
                        }
                    } else {
                        // No filtering: include all matched positions
                        refAligned.push(refAtom);
                        queryAligned.push(queryAtom);
                    }
                }
            }
            
            if (refAligned.length === 0) {
                console.warn('No matching atoms found for alignment. Attempting fallback...');
                // Fallback: try to match by sequence index if residue numbers don't match
                const minLen = Math.min(refSeq.length, querySeq.length, refCA.length, queryCA.length);
                const fallbackRef = [];
                const fallbackQuery = [];
                
                for (let i = 0; i < minLen; i++) {
                    if (i < refCA.length && i < queryCA.length) {
                        fallbackRef.push(refCA[i]);
                        fallbackQuery.push(queryCA[i]);
                    }
                }
                
                if (fallbackRef.length > 0) {
                    console.warn(`Using fallback alignment with ${fallbackRef.length} atoms`);
                    return { 
                        ref: fallbackRef, 
                        query: fallbackQuery,
                        stats: {
                            totalAligned: fallbackRef.length,
                            matchedPositions: fallbackRef.length,
                            identicalPositions: 0,
                            refGaps: 0,
                            queryGaps: 0,
                            coverage: (fallbackRef.length / minLen) * 100,
                            sequenceIdentity: 0,
                            shorterSeqLength: minLen
                        }
                    };
                }
                
                throw new Error('Could not map sequences to atoms. Please check that structures contain valid CA atoms.');
            }
            
            // Calculate statistics for the mapped atoms
            const stats = calculateAlignmentStats(alignedRef, alignedQuery, refSeq, querySeq);
            stats.matchedAtoms = refAligned.length;
            
            console.log(`Successfully mapped ${refAligned.length} atom pairs from ${alignedRef.length} aligned positions`);
            if (identityThreshold > 0) {
                console.log(`  (Filtered to ${refAligned.length} identical residue pairs with identity threshold ${identityThreshold}%)`);
            }
            
            return { 
                ref: refAligned, 
                query: queryAligned,
                stats: stats
            };
        }
        
        // Identify conserved regions (100% sequence identity)
        function identifyConservedRegions(aligned1, aligned2) {
            const conservation = [];
            for (let i = 0; i < aligned1.length; i++) {
                const isConserved = aligned1[i] !== '-' && aligned2[i] !== '-' && aligned1[i] === aligned2[i];
                conservation.push({
                    position: i,
                    conserved: isConserved,
                    refResidue: aligned1[i],
                    queryResidue: aligned2[i]
                });
            }
            return conservation;
        }
        
        // Global map to store conservation maps by structure name
        // Key: structure file name, Value: conservation map
        const structureConservationMaps = new Map();
        
        // Global map to store structure index to name mapping
        // Key: structure index in Molstar hierarchy, Value: structure file name
        const structureIndexToName = new Map();
        
        // Visualize aligned structures in Molstar
        async function visualizeAlignedStructures() {
            if (!viewer || !alignmentData) return;
            
            await viewer.plugin.clear();
            alignedStructures = [];
            structureVisibility.clear();
            structureConservationMaps.clear(); // Clear previous maps
            structureIndexToName.clear(); // Clear index to name mapping
            
            const plugin = viewer.plugin;
            
            // Build conservation map for reference structure
            // Conservation is based on the first aligned structure's conservation data
            const firstAligned = alignmentData.aligned[0];
            const refConservationMap = new Map(); // Map from chain_residueNumber to conservation status
            
            if (firstAligned && firstAligned.conservation && firstAligned.alignmentRegion) {
                // Use the trimmed reference sequence (aligned region only)
                // Get the reference region boundaries
                const refRegion = firstAligned.alignmentRegion;
                const trimmedRefSequence = alignmentData.reference.sequence.slice(
                    refRegion.refStart, 
                    refRegion.refEnd + 1
                );
                
                // Map aligned positions to conservation status using trimmed sequence
                const alignedRef = firstAligned.sequenceAlignment.aligned1;
                let trimmedRefSeqIdx = 0; // Index in trimmed reference sequence
                
                for (let i = 0; i < alignedRef.length; i++) {
                    if (alignedRef[i] !== '-') {
                        // This position in the alignment corresponds to a residue in trimmed sequence
                        if (trimmedRefSeqIdx < trimmedRefSequence.length) {
                            const refResidue = trimmedRefSequence[trimmedRefSeqIdx];
                            if (refResidue) {
                                const key = `${refResidue.chain || 'A'}_${refResidue.number}`;
                                const isConserved = firstAligned.conservation[i] && firstAligned.conservation[i].conserved;
                                refConservationMap.set(key, isConserved);
                            }
                            trimmedRefSeqIdx++;
                        }
                    }
                }
            }
            
            console.log(`Reference conservation map size: ${refConservationMap.size}`);
            if (refConservationMap.size > 0) {
                const sampleKeys = Array.from(refConservationMap.keys()).slice(0, 5);
                console.log(`Sample reference conservation keys: ${sampleKeys.join(', ')}`);
            }
            
            // Load reference structure
            const refBlob = new Blob([alignmentData.reference.file.data], { type: 'text/plain' });
            const refUrl = URL.createObjectURL(refBlob);
            const refData = await plugin.builders.data.download({ url: refUrl, isBinary: false });
            const refTrajectory = await plugin.builders.structure.parseTrajectory(refData, alignmentData.reference.file.format);
            const refStructure = await plugin.builders.structure.hierarchy.applyPreset(refTrajectory, 'default');
            URL.revokeObjectURL(refUrl);
            
            // Wait a moment for structure to be fully added to hierarchy
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Get structure index for reference (after it's been added)
            const refStructures = plugin.managers.structure.hierarchy.current.structures;
            const refStructureIndex = refStructures.length > 0 ? refStructures.length - 1 : 0;
            
            // Store conservation map by structure name instead of index
            structureConservationMaps.set(alignmentData.reference.file.name, refConservationMap);
            // Store index to name mapping for reliable lookup
            structureIndexToName.set(refStructureIndex, alignmentData.reference.file.name);
            console.log(`Stored reference conservation map for ${alignmentData.reference.file.name} (structure index: ${refStructureIndex})`);
            
            alignedStructures.push({
                name: alignmentData.reference.file.name,
                structure: refStructure,
                structureIndex: refStructureIndex,
                isReference: true,
                visible: true,
                conservationMap: refConservationMap
            });
            structureVisibility.set(alignmentData.reference.file.name, true);
            
            // Load all query structures first (without transformation)
            // We'll use Molstar's superposition API to align them
            for (const aligned of alignmentData.aligned) {
                try {
                    // Load structure WITHOUT transformation - we'll use Molstar's superposition
                    const blob = new Blob([aligned.file.data], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const data = await plugin.builders.data.download({ url: url, isBinary: false });
                    const trajectory = await plugin.builders.structure.parseTrajectory(data, aligned.file.format);
                    const structure = await plugin.builders.structure.hierarchy.applyPreset(trajectory, 'default');
                    URL.revokeObjectURL(url);
                    
                    // Wait a moment for structure to be fully added to hierarchy
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Get structure index after loading
                    const queryStructures = plugin.managers.structure.hierarchy.current.structures;
                    const queryStructureIndex = queryStructures.length > 0 ? queryStructures.length - 1 : 0;
                    
                    console.log(`Loaded structure ${aligned.file.name} at index ${queryStructureIndex} (will be superposed)`);
                    
                    // Store the structure for later superposition
                    const finalStructure = structure;
                    
                    // Store index to name mapping
                    structureIndexToName.set(queryStructureIndex, aligned.file.name);
                    
                    // Build conservation map for query structure
                    const queryConservationMap = new Map();
                    if (aligned.conservation && aligned.trimmedSequence) {
                        const alignedQuery = aligned.sequenceAlignment.aligned2;
                        let querySeqIdx = 0;
                        
                        for (let i = 0; i < alignedQuery.length; i++) {
                            if (alignedQuery[i] !== '-') {
                                const queryResidue = aligned.trimmedSequence[querySeqIdx];
                                if (queryResidue) {
                                    const key = `${queryResidue.chain || 'A'}_${queryResidue.number}`;
                                    const isConserved = aligned.conservation[i] && aligned.conservation[i].conserved;
                                    queryConservationMap.set(key, isConserved);
                                }
                                querySeqIdx++;
                            }
                        }
                    }
                    
                    console.log(`Query conservation map size: ${queryConservationMap.size} for ${aligned.file.name}`);
                    if (queryConservationMap.size > 0) {
                        const sampleKeys = Array.from(queryConservationMap.keys()).slice(0, 5);
                        console.log(`Sample query conservation keys: ${sampleKeys.join(', ')}`);
                    }
                    
                    // Store conservation map by structure name instead of index
                    structureConservationMaps.set(aligned.file.name, queryConservationMap);
                    console.log(`Stored query conservation map for ${aligned.file.name} (structure index: ${queryStructureIndex})`);
                    
                    alignedStructures.push({
                        name: aligned.file.name,
                        structure: finalStructure,
                        structureIndex: queryStructureIndex,
                        isReference: false,
                        visible: true,
                        conservation: aligned.conservation,
                        conservationMap: queryConservationMap
                    });
                    structureVisibility.set(aligned.file.name, true);
                } catch (error) {
                    console.error(`Error loading aligned structure ${aligned.file.name}:`, error);
                }
            }
            
            // Verify structures are loaded
            const allStructures = plugin.managers.structure.hierarchy.current.structures;
            console.log(`Total structures loaded: ${allStructures.length}`);
            console.log(`Conservation maps stored: ${structureConservationMaps.size}`);
            
            // Wait a bit longer to ensure all structures are fully processed
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Use Molstar's superposition or apply manual transformation
            // Reference structure is at index 0, query structures start at index 1
            if (allStructures.length >= 2) {
                try {
                    const refStructure = allStructures[0];
                    const queryStructures = allStructures.slice(1);
                    
                    console.log(`Attempting to superpose ${queryStructures.length} query structure(s) onto reference...`);
                    
                    // Apply transformations using our calculated alignment
                    // Since Molstar's superposition builder may not be directly accessible,
                    // we'll apply the transformation by reloading with transformed coordinates
                    for (let i = 0; i < queryStructures.length; i++) {
                        const queryStructure = queryStructures[i];
                        const aligned = alignmentData.aligned[i];
                        
                        if (aligned && aligned.transformation) {
                            console.log(`Applying transformation to structure ${i + 1} (${aligned.file.name})...`);
                            
                            // Remove the untransformed structure
                            await plugin.managers.structure.hierarchy.remove([queryStructure]);
                            await new Promise(resolve => setTimeout(resolve, 50));
                            
                            // Create transformed PDB/CIF content
                            const transformedPDB = createTransformedPDB(aligned.file.data, aligned.transformation, aligned.file.format);
                            
                            // Load the transformed structure
                            const transformedBlob = new Blob([transformedPDB], { type: 'text/plain' });
                            const transformedUrl = URL.createObjectURL(transformedBlob);
                            const transformedData = await plugin.builders.data.download({ url: transformedUrl, isBinary: false });
                            const transformedTrajectory = await plugin.builders.structure.parseTrajectory(transformedData, aligned.file.format);
                            const transformedStructure = await plugin.builders.structure.hierarchy.applyPreset(transformedTrajectory, 'default');
                            URL.revokeObjectURL(transformedUrl);
                            
                            // Wait for structure to be added
                            await new Promise(resolve => setTimeout(resolve, 100));
                            
                            // Update the structure index mapping
                            const updatedStructures = plugin.managers.structure.hierarchy.current.structures;
                            // Find the index of the newly loaded transformed structure
                            let newIndex = -1;
                            for (let j = 0; j < updatedStructures.length; j++) {
                                if (updatedStructures[j] === transformedStructure) {
                                    newIndex = j;
                                    break;
                                }
                            }
                            // Fallback: use the last structure index
                            if (newIndex === -1 && updatedStructures.length > 0) {
                                newIndex = updatedStructures.length - 1;
                            }
                            
                            if (newIndex >= 0) {
                                structureIndexToName.set(newIndex, aligned.file.name);
                            }
                            
                            // Update alignedStructures
                            const alignedStruct = alignedStructures.find(s => s.name === aligned.file.name);
                            if (alignedStruct) {
                                alignedStruct.structure = transformedStructure;
                                alignedStruct.structureIndex = newIndex;
                            }
                            
                            console.log(`Applied transformation to ${aligned.file.name}, new index: ${newIndex}`);
                        }
                    }
                } catch (superError) {
                    console.error('Error during superposition:', superError);
                }
            }
            
            // Apply conservation-based coloring to all structures
            await applyConservationColoring();
            
            // Reset camera to show both structures properly overlaid
            // Use a slight delay to ensure structures are rendered before resetting camera
            await new Promise(resolve => setTimeout(resolve, 100));
            plugin.managers.camera.reset();
            
            // Update structure toggle controls
            updateStructureToggleControls();
        }
        
        // Apply conservation-based coloring to aligned structures
        async function applyConservationColoring() {
            if (!viewer || !alignmentData) return;
            
            try {
                const plugin = viewer.plugin;
                const structures = plugin.managers.structure.hierarchy.current.structures;
                
                if (!structures || structures.length === 0) {
                    console.warn('No structures found for conservation coloring');
                    return;
                }
                
                console.log(`Applying conservation-based coloring to ${structures.length} structures`);
                console.log(`Available conservation maps: ${structureConservationMaps.size}`);
                console.log(`Conservation map keys: ${Array.from(structureConservationMaps.keys()).join(', ')}`);
                
                // Create unique theme name
                const themeName = `conservation-alignment-${Math.random().toString(36).substring(7)}`;
                
                // Conservation color theme provider
                const ConservationColorThemeProvider = {
                    name: themeName,
                    label: 'Conservation (Aligned)',
                    category: "Custom",
                    factory: (ctx, props) => {
                        const structure = ctx.structure;
                        if (!structure || !structure.models || structure.models.length === 0) {
                            console.warn('No structure models in context');
                            return {
                                factory: ConservationColorThemeProvider.factory,
                                granularity: 'group',
                                color: () => 0x808080,
                                props: props
                            };
                        }
                        
                        // Find structure name by matching structure object
                        let structureName = null;
                        let matchedIndex = -1;
                        const currentStructures = plugin.managers.structure.hierarchy.current.structures;
                        
                        // First, try to find the structure index by iterating through all structures
                        // and checking if any of their models/components match
                        for (let i = 0; i < currentStructures.length; i++) {
                            const currentStruct = currentStructures[i];
                            
                            // Direct match
                            if (currentStruct === structure) {
                                matchedIndex = i;
                                break;
                            }
                            
                            // Check models
                            if (currentStruct.models) {
                                for (const model of currentStruct.models) {
                                    if (model === structure || (model.structure && model.structure === structure)) {
                                        matchedIndex = i;
                                        break;
                                    }
                                }
                                if (matchedIndex >= 0) break;
                            }
                            
                            // Check components
                            if (currentStruct.components) {
                                for (const component of currentStruct.components) {
                                    if (component === structure || (component.structure && component.structure === structure)) {
                                        matchedIndex = i;
                                        break;
                                    }
                                }
                                if (matchedIndex >= 0) break;
                            }
                        }
                        
                        // If we found a match, get the structure name
                        if (matchedIndex >= 0) {
                            structureName = structureIndexToName.get(matchedIndex);
                            if (!structureName) {
                                const alignedStruct = alignedStructures.find(s => s.structureIndex === matchedIndex);
                                if (alignedStruct) {
                                    structureName = alignedStruct.name;
                                }
                            }
                            if (structureName) {
                                console.log(`Matched structure at index ${matchedIndex}: ${structureName}`);
                            }
                        }
                        
                        // Fallback strategies if initial match failed
                        if (!structureName) {
                            // Try matching by structure cell
                            if (structure.cell) {
                                for (let i = 0; i < currentStructures.length; i++) {
                                    if (currentStructures[i].cell === structure.cell) {
                                        structureName = structureIndexToName.get(i);
                                        if (!structureName) {
                                            const alignedStruct = alignedStructures.find(s => s.structureIndex === i);
                                            if (alignedStruct) {
                                                structureName = alignedStruct.name;
                                            }
                                        }
                                        if (structureName) {
                                            console.log(`Matched structure by cell at index ${i}: ${structureName}`);
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            // Try matching by aligned structures direct reference
                            if (!structureName) {
                                for (const alignedStruct of alignedStructures) {
                                    if (alignedStruct.structure === structure) {
                                        structureName = alignedStruct.name;
                                        console.log(`Matched structure by alignedStructures direct reference: ${structureName}`);
                                        break;
                                    }
                                }
                            }
                            
                            // Last resort: if we have exactly 2 structures and we know the indices, 
                            // use the structure index from the hierarchy position
                            if (!structureName && currentStructures.length === 2 && structureIndexToName.size === 2) {
                                // Try to match by position in hierarchy
                                for (let i = 0; i < currentStructures.length; i++) {
                                    // If this structure is at index i and we have a name for it, use it
                                    if (structureIndexToName.has(i)) {
                                        // Check if this could be the structure by checking if it's the only one left
                                        structureName = structureIndexToName.get(i);
                                        console.log(`Matched structure by hierarchy position at index ${i}: ${structureName}`);
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // Debug logging
                        if (!structureName) {
                            console.warn(`Could not find structure name for structure object. Available indices: ${Array.from(structureIndexToName.keys()).join(', ')}, Available names: ${Array.from(structureIndexToName.values()).join(', ')}`);
                            console.warn(`Current structures count: ${currentStructures.length}, Aligned structures count: ${alignedStructures.length}`);
                        }
                        
                        // Get conservation map for this structure by name
                        const conservationMap = structureName ? structureConservationMaps.get(structureName) : null;
                        
                        if (!conservationMap || conservationMap.size === 0) {
                            console.warn(`No conservation map found for structure ${structureName || 'unknown'}`);
                            // Fallback: use different colors for reference vs query so we can see both structures
                            // Try to determine if it's reference by checking alignedStructures
                            const isReference = alignedStructures.find(s => s.structure === structure)?.isReference || false;
                            if (isReference) {
                                console.log(`Using fallback blue color for structure ${structureName || 'unknown'} (reference)`);
                                return {
                                    factory: ConservationColorThemeProvider.factory,
                                    granularity: 'group',
                                    color: () => 0x4A90E2, // Blue for reference (fallback)
                                    props: props
                                };
                            } else {
                                console.log(`Using fallback red color for structure ${structureName || 'unknown'} (query)`);
                                return {
                                    factory: ConservationColorThemeProvider.factory,
                                    granularity: 'group',
                                    color: () => 0xE24A4A, // Red for query (fallback)
                                    props: props
                                };
                            }
                        }
                        
                        console.log(`Using conservation map for structure ${structureName} (${conservationMap.size} entries)`);
                        
                        return {
                            factory: ConservationColorThemeProvider.factory,
                            granularity: 'group',
                            color: (location) => {
                                try {
                                    const unit = location.unit;
                                    const element = location.element;
                                    
                                    // If we still don't have structureName, try to find it from the unit/model
                                    let effectiveStructureName = structureName;
                                    if (!effectiveStructureName && unit && unit.model) {
                                        // Try to find which structure this unit belongs to
                                        for (let i = 0; i < currentStructures.length; i++) {
                                            const currentStruct = currentStructures[i];
                                            if (currentStruct.models) {
                                                for (const model of currentStruct.models) {
                                                    if (model === unit.model || (model.units && model.units.includes(unit))) {
                                                        effectiveStructureName = structureIndexToName.get(i);
                                                        if (!effectiveStructureName) {
                                                            const alignedStruct = alignedStructures.find(s => s.structureIndex === i);
                                                            if (alignedStruct) {
                                                                effectiveStructureName = alignedStruct.name;
                                                            }
                                                        }
                                                        if (effectiveStructureName) break;
                                                    }
                                                }
                                            }
                                            if (effectiveStructureName) break;
                                        }
                                    }
                                    
                                    // Get the conservation map using the effective structure name
                                    const effectiveConservationMap = effectiveStructureName ? structureConservationMaps.get(effectiveStructureName) : conservationMap;
                                    
                                    // Get residue index from element
                                    if (!unit || !unit.model || !unit.model.atomicHierarchy) {
                                        return 0x808080; // Gray fallback
                                    }
                                    
                                    const residueIndex = unit.model.atomicHierarchy.residueAtomSegments.index[element];
                                    
                                    // Get residue information - add safety checks
                                    if (!unit.model.atomicHierarchy.residues || 
                                        !unit.model.atomicHierarchy.residues.label_seq_id ||
                                        !unit.model.atomicHierarchy.residues.chainKey) {
                                        return 0x808080; // Gray fallback
                                    }
                                    
                                    const seqId = unit.model.atomicHierarchy.residues.label_seq_id.value(residueIndex);
                                    const chainKey = unit.model.atomicHierarchy.residues.chainKey.value(residueIndex);
                                    
                                    if (!unit.model.atomicHierarchy.chains || 
                                        !unit.model.atomicHierarchy.chains.label_asym_id) {
                                        return 0x808080; // Gray fallback
                                    }
                                    
                                    const chainId = unit.model.atomicHierarchy.chains.label_asym_id.value(chainKey) || 'A';
                                    
                                    // Look up conservation status
                                    const key = `${chainId}_${seqId}`;
                                    const isConserved = effectiveConservationMap ? effectiveConservationMap.get(key) : null;
                                    
                                    // Color scheme: conserved = green, variable = orange
                                    if (isConserved === true) {
                                        return 0x00FF00; // Green for conserved
                                    } else if (isConserved === false) {
                                        return 0xFF6600; // Orange for variable
                                    } else {
                                        // Not found in conservation map - might be outside aligned region
                                        // Use a light gray
                                        return 0xC0C0C0; // Light gray for unaligned
                                    }
                                } catch (error) {
                                    console.warn('Error getting conservation color:', error);
                                    return 0x808080; // Gray fallback
                                }
                            },
                            props: props,
                            description: 'Conservation-based coloring: Green = conserved, Orange = variable, Light gray = unaligned'
                        };
                    },
                    getParams: () => ({}),
                    defaultValues: {},
                    isApplicable: (ctx) => !!ctx.structure
                };
                
                // Register the color theme
                plugin.representation.structure.themes.colorThemeRegistry.add(ConservationColorThemeProvider);
                console.log(`Registered conservation theme: ${themeName}`);
                
                // Apply the theme to all aligned structures
                for (let i = 0; i < structures.length; i++) {
                    const structure = structures[i];
                    // Find structure name to check if we have a conservation map
                    const alignedStruct = alignedStructures.find(s => s.structureIndex === i || s.structure === structure);
                    const structureName = alignedStruct ? alignedStruct.name : null;
                    const hasMap = structureName ? structureConservationMaps.has(structureName) : false;
                    console.log(`Structure ${i} (${structureName || 'unknown'}): has conservation map = ${hasMap}`);
                    
                    if (structure.components && structure.components.length > 0) {
                        await plugin.managers.structure.component.updateRepresentationsTheme(
                            structure.components,
                            { color: themeName }
                        );
                        console.log(`Applied conservation theme to structure ${i} (${structureName || 'unknown'})`);
                    }
                }
                
                console.log('Successfully applied conservation-based coloring');
                
            } catch (error) {
                console.error('Error applying conservation coloring:', error);
                console.error(error.stack);
            }
        }
        
        // Create transformed PDB content
        function createTransformedPDB(originalContent, transformation, format) {
            if (format === 'mmcif' || format === 'cif') {
                return createTransformedCIF(originalContent, transformation);
            } else {
                return createTransformedPDBFile(originalContent, transformation);
            }
        }
        
        // Create transformed PDB file
        function createTransformedPDBFile(pdbContent, transformation) {
            const lines = pdbContent.split('\n');
            const transformed = [];
            
            for (const line of lines) {
                if (line.startsWith('ATOM') || line.startsWith('HETATM')) {
                    const x = parseFloat(line.substring(30, 38));
                    const y = parseFloat(line.substring(38, 46));
                    const z = parseFloat(line.substring(46, 54));
                    
                    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                        const transformedCoords = applyTransformation(
                            [{ x, y, z }], 
                            transformation.rotation, 
                            transformation.translation
                        )[0];
                        
                        const newLine = line.substring(0, 30) + 
                                      String(transformedCoords.x.toFixed(3)).padStart(8) +
                                      String(transformedCoords.y.toFixed(3)).padStart(8) +
                                      String(transformedCoords.z.toFixed(3)).padStart(8) +
                                      line.substring(54);
                        transformed.push(newLine);
                    } else {
                        transformed.push(line);
                    }
                } else {
                    transformed.push(line);
                }
            }
            
            return transformed.join('\n');
        }
        
        // Create transformed CIF file
        function createTransformedCIF(cifContent, transformation) {
            const lines = cifContent.split('\n');
            const transformed = [];
            let columnIndices = {};
            let inAtomSite = false;
            let headerFound = false;
            let cartnXIdx = -1, cartnYIdx = -1, cartnZIdx = -1;
            
            // First pass: find column indices and copy header
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                
                if (trimmedLine.startsWith('_atom_site.')) {
                    inAtomSite = true;
                    const fieldName = trimmedLine.split('.')[1].split(/\s+/)[0];
                    const idx = Object.keys(columnIndices).length;
                    columnIndices[fieldName] = idx;
                    
                    if (fieldName === 'Cartn_x') cartnXIdx = idx;
                    else if (fieldName === 'Cartn_y') cartnYIdx = idx;
                    else if (fieldName === 'Cartn_z') cartnZIdx = idx;
                    
                    transformed.push(line);
                    continue;
                }
                
                if (inAtomSite && trimmedLine && !trimmedLine.startsWith('#') && !headerFound) {
                    headerFound = true;
                    // Process this first data line and continue
                }
                
                if (!inAtomSite || !headerFound) {
                    transformed.push(line);
                    continue;
                }
                
                // Process data lines
                if (trimmedLine && !trimmedLine.startsWith('#')) {
                    const fields = trimmedLine.split(/\s+/).filter(f => f.length > 0);
                    if (fields.length > 0 && cartnXIdx >= 0 && cartnYIdx >= 0 && cartnZIdx >= 0) {
                        const x = parseFloat(fields[cartnXIdx]);
                        const y = parseFloat(fields[cartnYIdx]);
                        const z = parseFloat(fields[cartnZIdx]);
                        
                        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                            // Apply transformation
                            const transformedCoords = applyTransformation(
                                [{ x, y, z }], 
                                transformation.rotation, 
                                transformation.translation
                            )[0];
                            
                            // Replace coordinates in the fields array
                            fields[cartnXIdx] = transformedCoords.x.toFixed(3);
                            fields[cartnYIdx] = transformedCoords.y.toFixed(3);
                            fields[cartnZIdx] = transformedCoords.z.toFixed(3);
                            
                            // Reconstruct line (CIF uses space-separated fields, but we need to preserve formatting)
                            // For simplicity, join with spaces (CIF format is flexible with whitespace)
                            transformed.push(fields.join(' '));
                        } else {
                            transformed.push(line);
                        }
                    } else {
                        transformed.push(line);
                    }
                } else {
                    transformed.push(line);
                }
            }
            
            return transformed.join('\n');
        }
        
        // Display alignment results
        function displayAlignmentResults() {
            const resultsSection = document.getElementById('alignment-results-section');
            resultsSection.style.display = 'block';
            
            if (!alignmentData || alignmentData.aligned.length === 0) {
                console.error('No alignment data available');
                return;
            }
            
            // Calculate average RMSD
            const avgRMSD = alignmentData.aligned.reduce((sum, a) => sum + a.rmsd, 0) / alignmentData.aligned.length;
            document.getElementById('alignment-rmsd').textContent = avgRMSD.toFixed(2);
            
            // Calculate average alignment statistics
            let totalAlignedResidues = 0;
            let totalCoverage = 0;
            let totalSequenceIdentity = 0;
            let conservedCount = 0;
            let variableCount = 0;
            
            alignmentData.aligned.forEach(aligned => {
                if (aligned.alignmentStats) {
                    totalAlignedResidues += aligned.alignmentStats.matchedAtoms || aligned.alignedCA.ref.length;
                    totalCoverage += aligned.alignmentStats.coverage || 0;
                    totalSequenceIdentity += aligned.alignmentStats.sequenceIdentity || 0;
                } else {
                    // Fallback for backward compatibility
                    totalAlignedResidues += aligned.alignedCA.ref.length;
                }
                
                // Count conserved and variable residues
                aligned.conservation.forEach(cons => {
                    if (cons.conserved) conservedCount++;
                    else if (cons.refResidue !== '-' && cons.queryResidue !== '-') variableCount++;
                });
            });
            
            // Average across all alignments
            const avgAlignedResidues = Math.round(totalAlignedResidues / alignmentData.aligned.length);
            const avgCoverage = (totalCoverage / alignmentData.aligned.length).toFixed(1);
            const avgSequenceIdentity = (totalSequenceIdentity / alignmentData.aligned.length).toFixed(1);
            conservedCount = Math.round(conservedCount / alignmentData.aligned.length);
            variableCount = Math.round(variableCount / alignmentData.aligned.length);
            
            // Update summary statistics
            document.getElementById('aligned-residues-count').textContent = avgAlignedResidues;
            document.getElementById('alignment-coverage').textContent = avgCoverage;
            document.getElementById('sequence-identity').textContent = avgSequenceIdentity;
            document.getElementById('conserved-count').textContent = conservedCount;
            document.getElementById('variable-count').textContent = variableCount;
            
            // Display detailed statistics for each structure
            const detailedStatsDiv = document.getElementById('detailed-alignment-stats');
            detailedStatsDiv.innerHTML = '<div style="margin-bottom: 5px; font-weight: bold; font-size: 12px;">Per-Structure Statistics:</div>';
            
            alignmentData.aligned.forEach((aligned, index) => {
                const stats = aligned.alignmentStats || {};
                const region = aligned.alignmentRegion || {};
                const statsDiv = document.createElement('div');
                statsDiv.style.cssText = 'margin-bottom: 8px; padding: 6px; background: hsl(0, 0%, 100%); border: 1px solid #ddd; border-radius: 4px; font-size: 11px;';
                
                let statsHtml = `<div style="font-weight: bold; margin-bottom: 4px;">${aligned.file.name}:</div>`;
                statsHtml += `<div style="margin-left: 10px; margin-bottom: 2px;">RMSD: ${aligned.rmsd.toFixed(2)} Å</div>`;
                
                if (region.refStart !== undefined && region.refEnd !== undefined) {
                    statsHtml += `<div style="margin-left: 10px; margin-bottom: 2px; color: hsl(220, 9%, 46%);">Reference region: ${region.refStart + 1}-${region.refEnd + 1} (${region.refTrimmedLength} residues)</div>`;
                }
                if (region.queryStart !== undefined && region.queryEnd !== undefined) {
                    statsHtml += `<div style="margin-left: 10px; margin-bottom: 2px; color: hsl(220, 9%, 46%);">Query region: ${region.queryStart + 1}-${region.queryEnd + 1} (${region.queryTrimmedLength} residues)</div>`;
                }
                
                if (stats.matchedAtoms) {
                    statsHtml += `<div style="margin-left: 10px; margin-bottom: 2px;">Aligned Residues: ${stats.matchedAtoms}</div>`;
                }
                if (stats.coverage !== undefined) {
                    statsHtml += `<div style="margin-left: 10px; margin-bottom: 2px;">Coverage: ${stats.coverage.toFixed(1)}%</div>`;
                }
                if (stats.sequenceIdentity !== undefined) {
                    statsHtml += `<div style="margin-left: 10px; margin-bottom: 2px;">Sequence Identity: ${stats.sequenceIdentity.toFixed(1)}%</div>`;
                }
                if (stats.matchedPositions) {
                    statsHtml += `<div style="margin-left: 10px; margin-bottom: 2px;">Matched Positions: ${stats.matchedPositions} / ${stats.totalAligned}</div>`;
                }
                
                statsDiv.innerHTML = statsHtml;
                detailedStatsDiv.appendChild(statsDiv);
            });
        }
        
        // Update structure toggle controls
        function updateStructureToggleControls() {
            const toggleList = document.getElementById('structure-toggle-list');
            toggleList.innerHTML = '';
            
            alignedStructures.forEach((struct, index) => {
                const toggleItem = document.createElement('div');
                toggleItem.className = 'structure-toggle-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `toggle-struct-${index}`;
                checkbox.checked = structureVisibility.get(struct.name) !== false;
                checkbox.addEventListener('change', () => {
                    structureVisibility.set(struct.name, checkbox.checked);
                    toggleStructureVisibility(struct.name, checkbox.checked);
                });
                
                const label = document.createElement('label');
                label.htmlFor = `toggle-struct-${index}`;
                label.textContent = struct.name + (struct.isReference ? ' (Reference)' : '');
                
                toggleItem.appendChild(checkbox);
                toggleItem.appendChild(label);
                toggleList.appendChild(toggleItem);
            });
        }
        
        // Toggle structure visibility
        async function toggleStructureVisibility(name, visible) {
            const struct = alignedStructures.find(s => s.name === name);
            if (!struct || !struct.structure) return;
            
            // This would require Molstar API to show/hide structures
            // For now, we'll reload the visible structures
            if (visible) {
                // Structure should already be visible
            } else {
                // Hide structure - would need Molstar API
                console.log('Hiding structure:', name);
            }
        }
        
        // Display sequence alignment
        function displaySequenceAlignment() {
            const alignmentView = document.getElementById('sequence-alignment-view');
            const alignmentDisplay = document.getElementById('sequence-alignment-display');
            alignmentView.style.display = 'block';
            
            let html = '';
            
            // Display alignment information header
            html += `<div style="margin-bottom: 10px; padding: 8px; background: hsl(210, 40%, 98%); border-radius: 4px; font-size: 11px;">`;
            html += `<div style="font-weight: bold; margin-bottom: 4px;">Local Alignment (Smith-Waterman)</div>`;
            html += `<div style="margin-left: 10px; color: hsl(220, 9%, 46%);">Only the aligned regions are shown below. Extra residues outside the aligned region have been trimmed.</div>`;
            html += `</div>`;
            
            // Display reference sequence (trimmed to aligned region)
            if (alignmentData.aligned.length > 0) {
                const firstAligned = alignmentData.aligned[0];
                const refRegion = firstAligned.alignmentRegion;
                
                html += `<div class="sequence-alignment-line" style="font-weight: bold; margin-top: 10px;">`;
                html += `Reference: ${alignmentData.reference.file.name} `;
                if (refRegion) {
                    html += `<span style="font-weight: normal; color: hsl(220, 9%, 46%); font-size: 11px;">(positions ${refRegion.refStart + 1}-${refRegion.refEnd + 1} of ${alignmentData.reference.sequence.length} total)</span>`;
                }
                html += `</div>`;
                html += formatAlignedSequence('', firstAligned.sequenceAlignment.aligned1, true, firstAligned.conservation);
                
                // Display aligned sequences (trimmed)
            alignmentData.aligned.forEach((aligned, idx) => {
                    const region = aligned.alignmentRegion;
                    html += `<div class="sequence-alignment-line" style="font-weight: bold; margin-top: 10px;">`;
                    html += `${aligned.file.name} `;
                    if (region) {
                        html += `<span style="font-weight: normal; color: hsl(220, 9%, 46%); font-size: 11px;">(positions ${region.queryStart + 1}-${region.queryEnd + 1} of ${aligned.sequence.length} total)</span>`;
                    }
                    html += `</div>`;
                    html += formatAlignedSequence('', aligned.sequenceAlignment.aligned2, false, aligned.conservation);
                });
            } else {
                // Fallback if no alignment data
                html += `<div class="sequence-alignment-line" style="font-weight: bold;">Reference: ${alignmentData.reference.file.name}</div>`;
                html += formatAlignedSequence(alignmentData.reference.seqString, '', true);
            }
            
            alignmentDisplay.innerHTML = html;
            
            // Add click handlers for interactive highlighting
            alignmentDisplay.querySelectorAll('.sequence-alignment-line').forEach((line, idx) => {
                if (idx > 1 && (idx - 1) % 2 === 1) { // Skip header lines and info box
                    line.addEventListener('click', () => {
                        // Highlight corresponding region in 3D view
                        highlightRegionIn3D(idx);
                    });
                }
            });
        }
        
        // Format aligned sequence with conservation highlighting
        function formatAlignedSequence(originalSeq, alignedSeq, isRef, conservation) {
            let html = '<div class="sequence-alignment-line">';
            for (let i = 0; i < alignedSeq.length; i++) {
                const char = alignedSeq[i];
                if (char === '-') {
                    html += `<span class="gap-residue">-</span>`;
                } else {
                    const isConserved = conservation && conservation[i] && conservation[i].conserved;
                    if (isConserved) {
                        html += `<span class="conserved-residue">${char}</span>`;
                    } else {
                        html += `<span class="variable-residue">${char}</span>`;
                    }
                }
            }
            html += '</div>';
            return html;
        }
        
        // Highlight region in 3D view (placeholder)
        function highlightRegionIn3D(position) {
            console.log('Highlighting region at position:', position);
            // This would require Molstar API to highlight specific residues
        }
        
        // Export conservation analysis
        function exportConservationAnalysis() {
            if (!alignmentData) {
                alert('No alignment data to export.');
                return;
            }
            
            let csv = 'Residue_Position,Reference_Residue,Aligned_File,Aligned_Residue,Conserved,RMSD\n';
            
            alignmentData.aligned.forEach(aligned => {
                aligned.conservation.forEach((cons, idx) => {
                    if (cons.refResidue !== '-' && cons.queryResidue !== '-') {
                        csv += `${idx + 1},${cons.refResidue},${aligned.file.name},${cons.queryResidue},${cons.conserved ? 'Yes' : 'No'},${aligned.rmsd.toFixed(3)}\n`;
                    }
                });
            });
            
            // Add sequence alignment
            csv += '\n\nSequence Alignment:\n';
            csv += `Reference: ${alignmentData.reference.file.name}\n`;
            csv += alignmentData.aligned[0]?.sequenceAlignment.aligned1 || '' + '\n';
            alignmentData.aligned.forEach(aligned => {
                csv += `${aligned.file.name}:\n`;
                csv += aligned.sequenceAlignment.aligned2 + '\n';
            });
            
            // Create download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'conservation_analysis.csv';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Initialize single session mode (normal single viewer)
        async function initializeSingleSessionMode() {
            currentSessionMode = 'single';
            const container = document.getElementById('container');
            container.className = 'single-view single-session-mode';
            
            // Clean up dual session viewers if they exist
            if (leftViewer && leftViewer.plugin) {
                await leftViewer.plugin.clear();
                leftViewer.plugin.dispose();
                leftViewer = null;
            }
            if (rightViewer && rightViewer.plugin) {
                await rightViewer.plugin.clear();
                rightViewer.plugin.dispose();
                rightViewer = null;
            }
            
            // Ensure main viewer exists and is configured normally
            if (!viewer || !viewer.plugin) {
                const viewerContainer = document.getElementById('viewer-container');
                if (viewerContainer) {
                    viewerContainer.innerHTML = '';
                }
                
                viewer = await molstar.Viewer.create('viewer-container', {
                    layoutIsExpanded: false,
                    layoutShowControls: false,
                    layoutShowLeftPanel: false,
                    layoutShowSequence: false,
                    layoutShowLog: false,
                    viewportShowExpand: false,
                    viewportShowSelectionMode: false,
                    viewportShowAnimation: false
                });
            }
        }
        
        // Initialize dual session mode (left = original, right = predicted)
        async function initializeDualSessionMode() {
            currentSessionMode = 'dual';
            const container = document.getElementById('container');
            container.className = 'single-view dual-session-mode';
            
            // Clean up existing viewers
            // Clear main viewer to remove background content
            if (viewer && viewer.plugin) {
                await viewer.plugin.clear();
                // Don't dispose main viewer, just clear it to remove background structures
            }
            
            if (leftViewer && leftViewer.plugin) {
                await leftViewer.plugin.clear();
                leftViewer.plugin.dispose();
                leftViewer = null;
            }
            if (rightViewer && rightViewer.plugin) {
                await rightViewer.plugin.clear();
                rightViewer.plugin.dispose();
                rightViewer = null;
            }
            
            // Clear dual viewer containers
            document.getElementById('left-viewer').innerHTML = '';
            document.getElementById('right-viewer').innerHTML = '';
            
            // Create left viewer for original structure
            leftViewer = await molstar.Viewer.create('left-viewer', {
                layoutIsExpanded: false,
                layoutShowControls: false,
                layoutShowLeftPanel: false,
                layoutShowSequence: false,
                layoutShowLog: false,
                viewportShowExpand: false,
                viewportShowSelectionMode: false,
                viewportShowAnimation: false
            });
            
            // Create right viewer for predicted structure
            rightViewer = await molstar.Viewer.create('right-viewer', {
                layoutIsExpanded: false,
                layoutShowControls: false,
                layoutShowLeftPanel: false,
                layoutShowSequence: false,
                layoutShowLog: false,
                viewportShowExpand: false,
                viewportShowSelectionMode: false,
                viewportShowAnimation: false
            });
            
            console.log('Dual session mode initialized');
        }
        
        // Initialize alignment mode (single viewer with alignment tools)
        async function initializeAlignmentMode() {
            currentSessionMode = 'align';
            const container = document.getElementById('container');
            container.className = 'single-view single-session-mode';
            
            // Clean up existing viewers
            // Dispose existing main viewer and recreate with alignment tools
            if (viewer && viewer.plugin) {
                await viewer.plugin.clear();
                viewer.plugin.dispose();
            }
            
            // Clean up dual session viewers if they exist
            if (leftViewer && leftViewer.plugin) {
                await leftViewer.plugin.clear();
                leftViewer.plugin.dispose();
                leftViewer = null;
            }
            if (rightViewer && rightViewer.plugin) {
                await rightViewer.plugin.clear();
                rightViewer.plugin.dispose();
                rightViewer = null;
            }
            
            const viewerContainer = document.getElementById('viewer-container');
            if (viewerContainer) {
                viewerContainer.innerHTML = '';
            }
            
            // Create viewer with alignment tools enabled
            viewer = await molstar.Viewer.create('viewer-container', {
                layoutIsExpanded: false,
                layoutShowControls: false,
                layoutShowLeftPanel: false,
                layoutShowSequence: false,
                layoutShowLog: true,  // Enable log for RMSD display
                viewportShowExpand: false,
                viewportShowSelectionMode: true,  // Enable selection mode for alignment
                viewportShowAnimation: false
            });
            
            console.log('Alignment mode initialized with log and selection tools enabled');
        }
        
        // Load structures in dual session mode
        async function loadDualSessionStructures(sequence, matchedStructure) {
            try {
                // Update headers
                document.getElementById('left-viewer-header').textContent = `Original: ${matchedStructure.name}`;
                document.getElementById('right-viewer-header').textContent = `Predicted: ${sequence.header}`;
                
                // Load original structure in left viewer
                const blob1 = new Blob([matchedStructure.data], { type: 'text/plain' });
                const url1 = URL.createObjectURL(blob1);
                const data1 = await leftViewer.plugin.builders.data.download({ url: url1, isBinary: false });
                const trajectory1 = await leftViewer.plugin.builders.structure.parseTrajectory(data1, matchedStructure.format);
                const structure1 = await leftViewer.plugin.builders.structure.hierarchy.applyPreset(trajectory1, 'default');
                URL.revokeObjectURL(url1);
                
                // Apply current color theme to original structure
                await applyColorThemeToViewer(leftViewer);
                
                // Load predicted structure in right viewer
                const blob2 = new Blob([sequence.pdbData], { type: 'text/plain' });
                const url2 = URL.createObjectURL(blob2);
                const data2 = await rightViewer.plugin.builders.data.download({ url: url2, isBinary: false });
                const trajectory2 = await rightViewer.plugin.builders.structure.parseTrajectory(data2, 'pdb');
                const structure2 = await rightViewer.plugin.builders.structure.hierarchy.applyPreset(trajectory2, 'default');
                URL.revokeObjectURL(url2);
                
                // Apply pLDDT coloring to predicted structure
                await applyPLDDTColoringToViewer(rightViewer);
                
                console.log('Dual session structures loaded successfully');
                
            } catch (error) {
                console.error('Error loading dual session structures:', error);
            }
        }
        
        // Apply pLDDT coloring to a specific viewer
        async function applyPLDDTColoringToViewer(targetViewer) {
            try {
                const structures = targetViewer.plugin.managers.structure.hierarchy.current.structures;
                
                if (!structures || structures.length === 0) {
                    console.warn('No structures found for pLDDT coloring');
                    return;
                }

                const structureData = structures[0].cell.obj?.data;
                if (structureData) {
                    try {
                        const model = structureData.models[0];
                        
                        if (model.atomicConformation && model.atomicConformation.B_iso_or_equiv) {
                            const themeName = 'plddt-confidence-' + Math.random().toString(36).substring(7);
                            
                            const PLDDTColorThemeProvider = {
                                name: themeName,
                                label: "pLDDT Confidence",
                                category: "Validation",
                                factory: (ctx, props) => {
                                    return {
                                        granularity: "group",
                                        color: (location) => {
                                            if (location.element !== undefined) {
                                                const model = ctx.structure.models[0];
                                                if (model && model.atomicConformation && model.atomicConformation.B_iso_or_equiv) {
                                                    const bFactor = model.atomicConformation.B_iso_or_equiv.value(location.element) - 0.04;
                                                    
                                                    if (bFactor > 0.9) {
                                                        return 0x0053D6; // Dark blue - very high confidence
                                                    } else if (bFactor > 0.7) {
                                                        return 0x65CBF3; // Light blue - confident
                                                    } else if (bFactor > 0.5) {
                                                        return 0xFFDB13; // Yellow - low confidence
                                                    } else {
                                                        return 0xFF7D45; // Orange - very low confidence
                                                    }
                                                }
                                            }
                                            return 0x777777; // Default gray
                                        }
                                    };
                                },
                                getParams: () => ({}),
                                defaultValues: {},
                                isApplicable: (ctx) => {
                                    const model = ctx.structure.models[0];
                                    return !!(model && model.atomicConformation && model.atomicConformation.B_iso_or_equiv);
                                }
                            };
                            
                            targetViewer.plugin.representation.structure.themes.colorThemeRegistry.add(PLDDTColorThemeProvider);
                            
                            await targetViewer.plugin.dataTransaction(async () => {
                                for (const structure of structures) {
                                    if (structure.components && structure.components.length > 0) {
                                        await targetViewer.plugin.managers.structure.component.updateRepresentationsTheme(
                                            structure.components, 
                                            { color: themeName }
                                        );
                                    }
                                }
                            });
                            
                            console.log('Successfully applied pLDDT coloring to viewer');
                            return;
                        }
                    } catch (structure_error) {
                        console.warn('Error creating custom pLDDT theme:', structure_error);
                    }
                }
                
                // Fallback to built-in themes
                const themeOptions = ['plddt-confidence', 'uncertainty', 'atom-test'];
                
                for (const themeName of themeOptions) {
                    try {
                        await targetViewer.plugin.dataTransaction(async () => {
                            for (const structure of structures) {
                                if (structure.components && structure.components.length > 0) {
                                    await targetViewer.plugin.managers.structure.component.updateRepresentationsTheme(
                                        structure.components, 
                                        { color: themeName }
                                    );
                                }
                            }
                        });
                        
                        console.log(`Successfully applied ${themeName} theme to viewer`);
                        return;
                        
                    } catch (theme_error) {
                        console.warn(`${themeName} theme failed:`, theme_error);
                    }
                }
                
            } catch (error) {
                console.warn('Error applying pLDDT coloring to viewer:', error);
            }
        }
        
        // Load predicted structure with pLDDT coloring
        async function loadPredictedStructure(pdbData) {
            try {
                // Clear existing structures and reset tracking
                await viewer.plugin.clear();
                predictedStructureIds.clear();
                
                // Load predicted structure
                const blob = new Blob([pdbData], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                const data = await viewer.plugin.builders.data.download({ url: url, isBinary: false });
                const trajectory = await viewer.plugin.builders.structure.parseTrajectory(data, 'pdb');
                const structure = await viewer.plugin.builders.structure.hierarchy.applyPreset(trajectory, 'default');
                
                URL.revokeObjectURL(url);
                
                // Track this structure as predicted
                if (structure && structure.cell) {
                    predictedStructureIds.add(structure.cell.transform.ref);
                    console.log('Added predicted structure to tracking:', structure.cell.transform.ref);
                }
                
                // Apply pLDDT coloring specifically to this structure
                await applyPLDDTColoringToStructure(structure);
                
                console.log('Predicted structure loaded with pLDDT coloring');
                
            } catch (error) {
                console.error('Error loading predicted structure:', error);
            }
        }
        
        // Load structures for alignment
        async function loadStructuresForAlignment(sequence, matchedFile) {
            try {
                // Clear existing structures and reset tracking
                await viewer.plugin.clear();
                predictedStructureIds.clear();
                
                // Load predicted structure
                const blob1 = new Blob([sequence.pdbData], { type: 'text/plain' });
                const url1 = URL.createObjectURL(blob1);
                const data1 = await viewer.plugin.builders.data.download({ url: url1, isBinary: false });
                const trajectory1 = await viewer.plugin.builders.structure.parseTrajectory(data1, 'pdb');
                const structure1 = await viewer.plugin.builders.structure.hierarchy.applyPreset(trajectory1, 'default');
                URL.revokeObjectURL(url1);
                
                // Track the predicted structure
                if (structure1 && structure1.cell) {
                    predictedStructureIds.add(structure1.cell.transform.ref);
                    console.log('Added predicted structure to alignment tracking:', structure1.cell.transform.ref);
                }
                
                // Apply pLDDT coloring to predicted structure
                await applyPLDDTColoringToStructure(structure1);
                
                // Load matched structure (this will get regular coloring)
                const blob2 = new Blob([matchedFile.data], { type: 'text/plain' });
                const url2 = URL.createObjectURL(blob2);
                const data2 = await viewer.plugin.builders.data.download({ url: url2, isBinary: false });
                const trajectory2 = await viewer.plugin.builders.structure.parseTrajectory(data2, matchedFile.format);
                const structure2 = await viewer.plugin.builders.structure.hierarchy.applyPreset(trajectory2, 'default');
                URL.revokeObjectURL(url2);
                
                // Apply current color scheme to the non-predicted structure
                if (structure2 && structure2.components) {
                    await viewer.plugin.dataTransaction(async () => {
                        await viewer.plugin.managers.structure.component.updateRepresentationsTheme(
                            structure2.components, 
                            { color: getColorThemeName(), params: getColorThemeParams() }
                        );
                    });
                }
                
                // Start monitoring for RMSD values
                startRMSDMonitoring(sequence);
                
                console.log('Both structures loaded for alignment - predicted with pLDDT, matched with current theme');
            } catch (error) {
                console.error('Error loading structures for alignment:', error);
            }
        }
        
        // Start monitoring for RMSD values in log
        function startRMSDMonitoring(sequence) {
            if (!viewer || !viewer.plugin) return;
            
            // Create a mutation observer to watch for log changes
            const viewerContainer = document.getElementById('viewer-container');
            if (!viewerContainer) return;

            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList') {
                        // Check for log entries containing RMSD
                        const logEntries = viewerContainer.querySelectorAll('.msp-log-entry');
                        logEntries.forEach(entry => {
                            const text = entry.textContent || '';
                            const rmsdMatch = text.match(/RMSD[:\s]+([0-9.]+)/i);
                            if (rmsdMatch) {
                                const rmsdValue = parseFloat(rmsdMatch[1]);
                                updateSequenceRMSD(sequence, rmsdValue);
                                observer.disconnect(); // Stop monitoring after finding RMSD
                            }
                        });
                    }
                });
            });

            observer.observe(viewerContainer, {
                childList: true,
                subtree: true
            });

            // Also check periodically for RMSD in any text content
            const intervalId = setInterval(() => {
                const allText = viewerContainer.textContent || '';
                const rmsdMatch = allText.match(/RMSD[:\s]+([0-9.]+)/i);
                if (rmsdMatch) {
                    const rmsdValue = parseFloat(rmsdMatch[1]);
                    updateSequenceRMSD(sequence, rmsdValue);
                    clearInterval(intervalId);
                    observer.disconnect();
                }
            }, 2000);

            // Stop monitoring after 30 seconds
            setTimeout(() => {
                clearInterval(intervalId);
                observer.disconnect();
            }, 30000);
        }
        
        // Update sequence RMSD score
        function updateSequenceRMSD(sequence, rmsdValue) {
            const index = parsedSequences.findIndex(seq => seq.header === sequence.header);
            if (index !== -1) {
                parsedSequences[index].rmsdScore = rmsdValue;
                updateSequenceList();
                console.log(`Updated RMSD for ${sequence.header}: ${rmsdValue.toFixed(3)}Å`);
            }
        }
        
        // Download sequence PDB
        function downloadSequencePDB(index) {
            const seq = parsedSequences[index];
            if (!seq.pdbData) {
                vscode.postMessage({
                    command: 'showError',
                    message: 'No PDB data available for this sequence'
                });
                return;
            }
            
            try {
                const filename = `${seq.header.replace(/[^a-zA-Z0-9]/g, '_')}_esmfold.pdb`;
                
                // Use VSCode save dialog
                vscode.postMessage({
                    command: 'downloadStructure',
                    data: seq.pdbData,
                    filename: filename,
                    format: 'pdb'
                });
                
                console.log(`Download initiated for ${seq.header}`);
            } catch (error) {
                console.error('Error downloading PDB:', error);
                vscode.postMessage({
                    command: 'showError',
                    message: 'Error downloading PDB file: ' + error.message
                });
            }
        }
        
        // Clear all sequences
        function clearAllSequences() {
            parsedSequences = [];
            selectedSequenceIndex = -1;
            updateSequenceList();
            document.getElementById('parsed-sequences-section').style.display = 'none';
            // Keep align-mode-section visible if seq alignment is enabled
            // document.getElementById('align-mode-section').style.display = 'none';
            document.getElementById('fasta-textarea').value = '';
            document.getElementById('sequence-name').value = '';
            document.getElementById('single-sequence-textarea').value = '';
        }
        
        // Handle display mode changes
        function handleDisplayModeChange() {
            const dualRadio = document.getElementById('dual-session-radio');
            const seqOnlyRadio = document.getElementById('seq-only-radio');
            const alignRadio = document.getElementById('align-mode-radio');
            
            if (dualRadio.checked) {
                currentDisplayMode = 'dual';
            } else if (seqOnlyRadio.checked) {
                currentDisplayMode = 'seq-only';
            } else if (alignRadio.checked) {
                currentDisplayMode = 'align';
            }
            
            // If we have a selected sequence, update the display immediately
            if (selectedSequenceIndex !== -1 && parsedSequences[selectedSequenceIndex]) {
                const seq = parsedSequences[selectedSequenceIndex];
                if (seq.status === 'completed' && seq.pdbData) {
                    displaySequenceStructure(seq);
                }
            }
            
            updateViewerConfigForAlignment();
        }
        
        // Toggle pLDDT info section
        function togglePLDDTInfo() {
            const toggle = document.getElementById('plddt-info-toggle');
            const content = document.getElementById('plddt-info-content');
            
            if (toggle.checked) {
                content.classList.add('active');
            } else {
                content.classList.remove('active');
            }
        }
        
        // Update viewer configuration for alignment
        async function updateViewerConfigForAlignment() {
            if (sequenceAlignmentEnabled && currentLayoutMode === 'single' && currentDisplayMode === 'align') {
                // Enable log and selection mode for alignment
                if (viewer && viewer.plugin) {
                    try {
                        // Update layout to show log and selection tools
                        await viewer.plugin.layout.setProps({
                            layoutShowLog: true,
                            viewportShowSelectionMode: true
                        });
                        console.log('Alignment mode enabled - log and selection tools available');
                    } catch (error) {
                        console.warn('Could not update viewer layout for alignment:', error);
                    }
                }
            } else {
                // Disable log and selection mode
                if (viewer && viewer.plugin) {
                    try {
                        await viewer.plugin.layout.setProps({
                            layoutShowLog: false,
                            viewportShowSelectionMode: false
                        });
                        console.log('Alignment mode disabled');
                    } catch (error) {
                        console.warn('Could not reset viewer layout:', error);
                    }
                }
            }
        }
        
        // Reset viewer configuration
        function resetViewerConfig() {
            if (viewer && viewer.plugin) {
                console.log('Resetting viewer configuration');
            }
        }
        
        // Apply pLDDT confidence coloring to a specific structure (adapted from esmfold.html)
        async function applyPLDDTColoringToStructure(structure) {
            try {
                console.log('Applying pLDDT coloring...');
                
                // Get the current structures from the viewer (like esmfold.html does)
                const structures = viewer.plugin.managers.structure.hierarchy.current.structures;
                
                if (!structures || structures.length === 0) {
                    console.warn('No structures found for pLDDT coloring');
                    return;
                }

                console.log(`Applying pLDDT coloring to ${structures.length} structure(s)`);
                
                // Extract and debug pLDDT values from the structure (exactly like esmfold.html)
                const structureData = structures[0].cell.obj?.data;
                if (structureData) {
                    console.log('Structure data found, creating custom pLDDT color theme...');
                    
                    try {
                        // Get the first model to verify B-factor data exists
                        const model = structureData.models[0];
                        
                        if (model.atomicConformation && model.atomicConformation.B_iso_or_equiv) {
                            console.log('Found B_iso_or_equiv in atomicConformation');
                            
                            // Create custom pLDDT color theme with complete provider structure (from esmfold.html)
                            const themeName = 'plddt-confidence-' + Math.random().toString(36).substring(7);
                            
                            // Create a complete color theme provider (exactly like esmfold.html)
                            const PLDDTColorThemeProvider = {
                                name: themeName,
                                label: "pLDDT Confidence",
                                category: "Validation",
                                factory: (ctx, props) => {
                                    return {
                                        granularity: "group",
                                        color: (location) => {
                                            // Get B-factor value from the location
                                            if (location.element !== undefined) {
                                                const model = ctx.structure.models[0];
                                                if (model && model.atomicConformation && model.atomicConformation.B_iso_or_equiv) {
                                                    const bFactor = model.atomicConformation.B_iso_or_equiv.value(location.element) - 0.04;
                                                    
                                                    // ESMFold/AlphaFold pLDDT color scheme
                                                    if (bFactor > 0.9) {
                                                        return 0x0053D6; // Dark blue - very high confidence
                                                    } else if (bFactor > 0.7) {
                                                        return 0x65CBF3; // Light blue - confident
                                                    } else if (bFactor > 0.5) {
                                                        return 0xFFDB13; // Yellow - low confidence
                                                    } else {
                                                        return 0xFF7D45; // Orange - very low confidence
                                                    }
                                                }
                                            }
                                            return 0x777777; // Default gray
                                        }
                                    };
                                },
                                getParams: () => ({}),
                                defaultValues: {},
                                isApplicable: (ctx) => {
                                    // Check if structure has B-factor data
                                    const model = ctx.structure.models[0];
                                    return !!(model && model.atomicConformation && model.atomicConformation.B_iso_or_equiv);
                                }
                            };
                            
                            // Register the color theme (exactly like esmfold.html)
                            viewer.plugin.representation.structure.themes.colorThemeRegistry.add(
                                PLDDTColorThemeProvider
                            );
                            console.log('Registered custom pLDDT color theme:', themeName);
                            
                            // Apply the custom theme using dataTransaction (exactly like esmfold.html)
                            await viewer.plugin.dataTransaction(async () => {
                                for (const structure of structures) {
                                    if (structure.components && structure.components.length > 0) {
                                        await viewer.plugin.managers.structure.component.updateRepresentationsTheme(
                                            structure.components, 
                                            { color: themeName }
                                        );
                                    }
                                }
                            });
                            
                            console.log('Successfully applied custom pLDDT color theme');
                            return;
                        }
                        
                    } catch (structure_error) {
                        console.warn('Error creating custom color theme:', structure_error);
                    }
                }
                
                // Fallback to built-in themes (exactly like esmfold.html)
                console.log('Falling back to built-in themes...');
                const themeOptions = [
                    'plddt-confidence',  // Direct pLDDT theme
                    'uncertainty',       // B-factor uncertainty coloring  
                    'atom-test',        // Generic atom property coloring
                ];
                
                for (const themeName of themeOptions) {
                    try {
                        console.log(`Trying color theme: ${themeName}`);
                        
                        await viewer.plugin.dataTransaction(async () => {
                            for (const structure of structures) {
                                if (structure.components && structure.components.length > 0) {
                                    await viewer.plugin.managers.structure.component.updateRepresentationsTheme(
                                        structure.components, 
                                        { color: themeName }
                                    );
                                }
                            }
                        });
                        
                        console.log(`Successfully applied ${themeName} color theme`);
                        return; // Success, exit the function
                        
                    } catch (theme_error) {
                        console.warn(`${themeName} theme failed:`, theme_error);
                        // Continue to next theme
                    }
                }
                
                console.warn('All coloring options failed');

            } catch (error) {
                console.warn('Error applying pLDDT coloring:', error);
            }
        }
        
        // Apply pLDDT confidence coloring (simplified version) - kept for backwards compatibility
        async function applyPLDDTColoring() {
            try {
                console.log('Applying pLDDT coloring to all structures...');
                
                // Get the current structures
                const structures = viewer.plugin.managers.structure.hierarchy.current.structures;
                
                if (!structures || structures.length === 0) {
                    console.warn('No structures found for pLDDT coloring');
                    return;
                }

                // Apply to first structure (backwards compatibility)
                if (structures.length > 0) {
                    await applyPLDDTColoringToStructure(structures[0]);
                }
                
            } catch (error) {
                console.warn('Error applying pLDDT coloring:', error);
            }
        }

        // Initialize the app
        init().catch(error => console.error('Failed to initialize app:', error));
    </script>
</body>
</html>